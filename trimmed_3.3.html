<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Video Splitter ‚Äî Link Upload & Captions</title>
<style>
:root{--bg:#0b1020;--card:#0f1724;--accent:#7c3aed;--accent-light:#8b5cf6;--success:#10b981;--warning:#f59e0b;--muted:#9aa4b2;--glass:rgba(255,255,255,0.03)}
*{box-sizing:border-box}
body{font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:linear-gradient(180deg,#05060a 0%, #0b1020 100%);color:#e6eef8;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px}
.wrap{width:980px;max-width:96%;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
h1{margin:0 0 8px;font-size:20px}
p.lead{margin:0 0 18px;color:var(--muted)}
.grid{display:grid;grid-template-columns:1fr 360px;gap:18px}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:14px;border-radius:10px}
input[type=file]{color:transparent}
.video-wrap{display:flex;flex-direction:column;gap:12px}
video{width:100%;border-radius:8px;background:#000;max-height:420px}
label.small{display:inline-block;font-size:12px;color:var(--muted);margin-bottom:6px}
.upload-tabs{display:flex;border-bottom:1px solid rgba(255,255,255,0.05);margin-bottom:12px}
.tab-btn{background:transparent;border:none;color:var(--muted);padding:8px 16px;cursor:pointer;font-size:13px;position:relative}
.tab-btn:hover{color:white}
.tab-btn.active{color:var(--accent)}
.tab-btn.active::after{content:'';position:absolute;bottom:-1px;left:0;right:0;height:2px;background:var(--accent)}
.tab-content{display:none}
.tab-content.active{display:block}
.link-input-container{display:flex;gap:8px;margin-top:8px}
.link-input{flex:1;padding:10px 12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:8px;color:white;font-size:13px}
.link-input:focus{outline:none;border-color:var(--accent)}
.link-help{font-size:11px;color:var(--muted);margin-top:4px}
.link-help a{color:var(--accent);text-decoration:none}
.link-help a:hover{text-decoration:underline}
.controls-container{display:flex;flex-direction:column;gap:12px}
.playback-controls{display:flex;align-items:center;gap:10px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
.time-navigation{display:flex;align-items:center;gap:6px}
.nav-btn{background:transparent;border:1px solid rgba(255,255,255,0.1);color:var(--muted);width:30px;height:30px;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px}
.nav-btn:hover{background:rgba(255,255,255,0.05);border-color:var(--accent);color:white}
.jump-btn{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--muted);padding:4px 8px;border-radius:6px;cursor:pointer;font-size:11px}
.jump-btn:hover{background:rgba(124,58,237,0.1);border-color:var(--accent);color:white}
.set-time-btn{background:rgba(124,58,237,0.15);border:1px solid var(--accent);color:white;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;font-weight:500}
.set-time-btn:hover{background:rgba(124,58,237,0.25)}
.time-display{font-family:'JetBrains Mono','Cascadia Code',monospace;font-size:13px;color:white;background:rgba(0,0,0,0.3);padding:4px 8px;border-radius:4px;min-width:80px;text-align:center}
.range-controls{display:flex;flex-direction:column;gap:14px;background:rgba(255,255,255,0.02);padding:14px;border-radius:8px}
.range-group{display:flex;align-items:center;gap:12px}
.range-label{font-size:13px;color:var(--muted);min-width:60px}
.range-wrapper{flex:1;display:flex;align-items:center;gap:10px}
input[type=range]{flex:1;height:6px;border-radius:3px;background:rgba(255,255,255,0.1);outline:none;cursor:pointer}
input[type=range]::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;background:var(--accent);cursor:pointer}
input[type=range]::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:var(--accent);border:none;cursor:pointer}
.time-input{width:70px;padding:6px 8px;background:transparent;border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:white;font-family:monospace;font-size:13px}
.time-input:focus{outline:none;border-color:var(--accent)}
.action-buttons{display:flex;gap:8px;align-items:center;justify-content:space-between}
.btn{background:var(--accent);border:none;padding:10px 16px;border-radius:8px;color:white;cursor:pointer;font-weight:500;display:flex;align-items:center;gap:6px}
.btn:hover{background:var(--accent-light)}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.1)}
.btn.secondary:hover{background:rgba(255,255,255,0.05);border-color:var(--accent)}
.btn:disabled{opacity:0.5;cursor:not-allowed}
.duration-badge{font-size:12px;padding:6px 10px;border-radius:999px;background:var(--glass);color:var(--muted);display:flex;align-items:center;gap:4px}
.duration-badge .highlight{color:white;font-weight:600}
.sidebar{display:flex;flex-direction:column;gap:12px}
.field{display:flex;flex-direction:column;gap:6px}
.smallmuted{font-size:13px;color:var(--muted)}
.download-list{display:flex;flex-direction:column;gap:8px}
a.download{display:inline-block;padding:8px 10px;background:linear-gradient(90deg, rgba(255,255,255,0.03), transparent);border-radius:8px;color:#cfe9ff;text-decoration:none;display:flex;justify-content:space-between;align-items:center}
a.download:hover{background:linear-gradient(90deg, rgba(255,255,255,0.06), transparent)}
footer.note{margin-top:12px;font-size:12px;color:var(--muted)}
progress{width:100%;height:8px;border-radius:4px;background:rgba(255,255,255,0.1);border:none}
progress::-webkit-progress-bar{background:rgba(255,255,255,0.1);border-radius:4px}
progress::-webkit-progress-value{background:var(--accent);border-radius:4px}
progress::-moz-progress-bar{background:var(--accent);border-radius:4px}
.keyboard-hint{font-size:11px;color:var(--muted);margin-top:2px}
.keyboard-key{display:inline-block;padding:1px 4px;background:rgba(255,255,255,0.1);border-radius:3px;font-family:monospace;font-size:10px;margin:0 1px}
.segment-indicator{height:4px;background:rgba(124,58,237,0.3);border-radius:2px;position:relative;margin:4px 0}
.segment-indicator::before{content:'';position:absolute;left:0;width:var(--start-percent);height:100%;background:transparent}
.segment-indicator::after{content:'';position:absolute;left:var(--start-percent);width:calc(var(--end-percent) - var(--start-percent));height:100%;background:var(--accent);border-radius:2px}
.percentage-display{font-family:'JetBrains Mono',monospace;font-size:12px;color:var(--accent);background:rgba(124,58,237,0.1);padding:2px 6px;border-radius:4px;min-width:50px;text-align:center}
.percentage-label{font-size:11px;color:var(--muted);margin-top:2px}
.progress-info{display:flex;justify-content:space-between;font-size:11px;color:var(--muted);margin-top:4px}
.time-with-percent{display:flex;flex-direction:column;align-items:center;gap:2px}
.range-with-percent{display:flex;align-items:center;gap:8px;width:100%}
.percent-input-group{display:flex;align-items:center;gap:6px;margin-top:4px}
.percent-input{width:60px;padding:4px 6px;background:transparent;border:1px solid rgba(255,255,255,0.08);border-radius:4px;color:white;font-size:12px;text-align:center}
.percent-input:focus{outline:none;border-color:var(--accent)}
.export-progress-info{display:flex;justify-content:space-between;margin-top:6px;font-size:12px}
.export-progress-percent{color:var(--accent);font-weight:600}
.export-progress-time{color:var(--muted)}
.audio-status{background:rgba(16,185,129,0.1);color:var(--success);border:1px solid rgba(16,185,129,0.3);padding:4px 8px;border-radius:6px;font-size:11px;display:inline-flex;align-items:center;gap:4px}
.audio-status.muted{background:rgba(156,163,175,0.1);color:var(--muted);}
.audio-status.error{background:rgba(239,68,68,0.1);color:#ef4444;}
.file-info{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.file-size{font-size:12px;color:var(--muted)}
.captions-container{margin-top:12px}
.captions-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.captions-header h3{font-size:14px;margin:0;color:var(--muted)}
.captions-controls{display:flex;gap:6px}
.captions-panel{background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;max-height:200px;overflow-y:auto}
.caption-line{margin-bottom:8px;padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:4px;font-size:12px}
.caption-time{font-family:monospace;color:var(--accent);font-size:11px;margin-right:8px}
.caption-text{color:white}
.no-captions{text-align:center;color:var(--muted);font-size:12px;padding:20px}
.volume-controls{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.volume-slider-container{display:flex;align-items:center;gap:10px}
.volume-slider{flex:1;height:6px;border-radius:3px;background:rgba(255,255,255,0.1);outline:none}
.volume-slider::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);cursor:pointer}
.volume-slider::-moz-range-thumb{width:14px;height:14px;border-radius:50%;background:var(--accent);border:none;cursor:pointer}
.volume-value{font-family:'JetBrains Mono',monospace;font-size:12px;color:var(--accent);min-width:40px;text-align:center}
.volume-presets{display:flex;gap:6px;margin-top:4px}
.volume-preset{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--muted);padding:3px 8px;border-radius:4px;cursor:pointer;font-size:10px}
.volume-preset:hover{background:rgba(124,58,237,0.1);border-color:var(--accent);color:white}
.volume-preset.active{background:var(--accent);border-color:var(--accent);color:white}
.volume-visualizer{height:4px;border-radius:2px;background:linear-gradient(90deg, var(--accent) 0%, var(--accent) var(--volume-percent, 100%), rgba(255,255,255,0.1) var(--volume-percent, 100%))}
.volume-label{display:flex;justify-content:space-between;align-items:center}
.volume-label span:last-child{font-size:11px;color:var(--muted)}
.download-container {
background: linear-gradient(90deg, rgba(255,255,255,0.03), transparent);
border-radius: 8px;
padding: 12px;
margin-bottom: 8px;
transition: background 0.2s;
border: 1px solid rgba(255,255,255,0.05);
}
.download-container:hover {
background: linear-gradient(90deg, rgba(255,255,255,0.06), transparent);
border-color: rgba(124,58,237,0.3);
}
.download-btn {
background: var(--accent);
border: none;
color: white;
padding: 6px 12px;
border-radius: 6px;
font-size: 12px;
cursor: pointer;
font-weight: 500;
transition: background 0.2s;
}
.download-btn:hover {
background: var(--accent-light);
}
.download-btn.success {
background: var(--success);
}
.download-btn.disabled {
background: var(--muted);
cursor: not-allowed;
}
.export-options {
display: flex;
flex-direction: column;
gap: 8px;
margin-top: 12px;
padding: 12px;
background: rgba(255,255,255,0.02);
border-radius: 8px;
}
.option-group {
display: flex;
flex-wrap: wrap;
gap: 8px;
align-items: center;
}
.quality-selector {
padding: 6px 10px;
background: transparent;
border: 1px solid rgba(255,255,255,0.1);
border-radius: 6px;
color: white;
font-size: 12px;
}
.quality-selector option {
background: var(--card);
color: white;
}
.performance-warning {
background: rgba(245,158,11,0.1);
border: 1px solid rgba(245,158,11,0.3);
color: var(--warning);
padding: 8px 12px;
border-radius: 6px;
font-size: 11px;
margin-top: 8px;
display: none;
}
.format-highlight {
background: rgba(124,58,237,0.2);
border: 1px solid var(--accent);
border-radius: 6px;
padding: 4px 8px;
}
.audio-format-selector {
padding: 6px 10px;
background: transparent;
border: 1px solid rgba(255,255,255,0.1);
border-radius: 6px;
color: white;
font-size: 12px;
min-width: 100px;
}
.audio-format-selector option {
background: var(--card);
color: white;
}
.audio-quality-selector {
padding: 4px 8px;
background: transparent;
border: 1px solid rgba(255,255,255,0.1);
border-radius: 4px;
color: white;
font-size: 11px;
min-width: 80px;
}
.audio-extract-container {
background: linear-gradient(90deg, rgba(255,255,255,0.02), transparent);
border-radius: 8px;
padding: 12px;
margin-top: 8px;
border: 1px solid rgba(255,255,255,0.05);
}
.audio-extract-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
}
.audio-extract-title {
font-size: 13px;
color: white;
font-weight: 500;
}
.audio-extract-controls {
display: flex;
gap: 8px;
align-items: center;
}
.audio-extract-btn {
background: linear-gradient(90deg, #8B5CF6, #7C3AED);
border: none;
color: white;
padding: 6px 12px;
border-radius: 6px;
font-size: 12px;
cursor: pointer;
font-weight: 500;
display: flex;
align-items: center;
gap: 4px;
}
.audio-extract-btn:hover {
background: linear-gradient(90deg, #9F67FF, #8B5CF6);
}
.audio-extract-btn:disabled {
opacity: 0.5;
cursor: not-allowed;
}
.memory-warning {
background: rgba(245,158,11,0.2);
border: 1px solid rgba(245,158,11,0.4);
color: var(--warning);
padding: 8px 12px;
border-radius: 6px;
margin-top: 8px;
font-size: 11px;
}
.export-complete {
background: rgba(16,185,129,0.1);
border: 1px solid rgba(16,185,129,0.3);
color: var(--success);
padding: 8px 12px;
border-radius: 6px;
margin-top: 8px;
font-size: 12px;
animation: fadeOut 3s forwards 2s;
}
@keyframes fadeOut {
from { opacity: 1; }
to { opacity: 0; }
}
.audio-format-badge {
background: rgba(124,58,237,0.2);
color: var(--accent);
font-size: 11px;
padding: 2px 6px;
border-radius: 4px;
border: 1px solid rgba(124,58,237,0.3);
}
.audio-quality-badge {
background: rgba(16,185,129,0.1);
color: var(--success);
font-size: 10px;
padding: 1px 4px;
border-radius: 3px;
}
.audio-format-warning {
background: rgba(245,158,11,0.1);
border: 1px solid rgba(245,158,11,0.3);
color: var(--warning);
padding: 6px 10px;
border-radius: 6px;
font-size: 11px;
margin-top: 4px;
display: none;
}
.converting-progress {
background: rgba(124,58,237,0.1);
border: 1px solid rgba(124,58,237,0.3);
color: var(--accent);
padding: 8px 12px;
border-radius: 6px;
margin-top: 8px;
font-size: 12px;
display: none;
}

/* NEW: Timeline Control Styles */
.timeline-container {
position: relative;
width: 100%;
height: 60px;
margin: 10px 0;
background: rgba(255,255,255,0.02);
border-radius: 8px;
padding: 8px;
cursor: pointer;
border: 1px solid rgba(255,255,255,0.05);
}
.timeline-track {
position: relative;
width: 100%;
height: 8px;
background: rgba(255,255,255,0.05);
border-radius: 4px;
margin-top: 20px;
overflow: hidden;
}
.timeline-progress {
position: absolute;
left: 0;
top: 0;
height: 100%;
background: var(--accent);
border-radius: 4px;
width: 0%;
transition: width 0.1s;
}
.timeline-seeker {
position: absolute;
left: 0%;
top: 50%;
transform: translate(-50%, -50%);
width: 24px;
height: 24px;
background: white;
border-radius: 50%;
cursor: grab;
z-index: 10;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
border: 2px solid var(--accent);
}
.timeline-seeker:active {
cursor: grabbing;
}
.timeline-markers {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 20px;
display: flex;
justify-content: space-between;
}
.timeline-marker {
position: absolute;
top: -20px;
transform: translateX(-50%);
font-size: 10px;
color: var(--muted);
font-family: 'JetBrains Mono', monospace;
}
.timeline-marker::after {
content: '';
position: absolute;
top: 20px;
left: 50%;
transform: translateX(-50%);
width: 1px;
height: 6px;
background: rgba(255,255,255,0.2);
}
.timeline-marker.main {
font-size: 11px;
color: white;
}
.timeline-marker.main::after {
height: 10px;
background: rgba(255,255,255,0.4);
}
.timeline-time-display {
position: absolute;
top: -30px;
left: 0;
transform: translateX(-50%);
background: var(--accent);
color: white;
padding: 4px 8px;
border-radius: 4px;
font-size: 12px;
font-family: 'JetBrains Mono', monospace;
white-space: nowrap;
display: none;
}
.timeline-seeker:hover .timeline-time-display {
display: block;
}
.segment-handle {
position: absolute;
top: 50%;
transform: translateY(-50%);
width: 12px;
height: 20px;
background: var(--accent);
cursor: ew-resize;
border-radius: 3px;
z-index: 5;
}
.segment-handle.start {
left: 0;
}
.segment-handle.end {
right: 0;
}
.timeline-segment {
position: absolute;
top: 0;
height: 100%;
background: rgba(124,58,237,0.3);
border-radius: 4px;
}
.segment-reset-btn {
position: absolute;
right: 8px;
top: 8px;
background: rgba(255,255,255,0.1);
border: none;
color: var(--muted);
padding: 4px 8px;
border-radius: 4px;
font-size: 11px;
cursor: pointer;
}
.segment-reset-btn:hover {
background: rgba(124,58,237,0.2);
color: white;
}
.timeline-controls {
display: flex;
justify-content: space-between;
margin-top: 8px;
font-size: 11px;
color: var(--muted);
}
.segment-info {
display: flex;
gap: 8px;
align-items: center;
}
.segment-toggle {
display: flex;
align-items: center;
gap: 4px;
}
.segment-toggle input {
margin: 0;
}
.segment-toggle label {
font-size: 11px;
cursor: pointer;
}
.full-video-notice {
background: rgba(16,185,129,0.1);
border: 1px solid rgba(16,185,129,0.3);
color: var(--success);
padding: 8px 12px;
border-radius: 6px;
margin-top: 8px;
font-size: 12px;
display: none;
}
.full-video-notice.active {
display: block;
}

@media (max-width:880px){.grid{grid-template-columns:1fr}}
@media (max-width:600px){
.playback-controls{flex-wrap:wrap}
.range-group{flex-direction:column;align-items:stretch}
.range-label{width:100%}
.range-with-percent{flex-direction:column;align-items:stretch}
.download-container {
flex-direction: column;
gap: 10px;
}
.audio-extract-container {
flex-direction: column;
}
.audio-extract-controls {
flex-wrap: wrap;
}
.timeline-container {
height: 50px;
}
.timeline-markers {
display: none;
}
}
</style>
<!-- Include lamejs for MP3 encoding -->
<script src="https://unpkg.com/lamejs@1.2.1/lame.min.js"></script>
</head>
<body>
<div class="wrap" role="application">
<h1>üé¨ Video Splitter ‚Äî Link Upload & Captions</h1>
<p class="lead">Upload videos via direct link or file, generate captions, adjust volume, trim, and extract audio.</p>
<div class="grid">
<div class="panel">
<div class="video-wrap">
<div class="file-info">
<label class="small">Upload Method</label>
<div class="file-size" id="fileSizeInfo"></div>
</div>
<!-- Upload Tabs -->
<div class="upload-tabs">
<button class="tab-btn active" data-tab="file-tab">üìÅ File Upload</button>
<button class="tab-btn" data-tab="link-tab">üîó Video Link</button>
</div>
<!-- File Upload Tab -->
<div id="file-tab" class="tab-content active">
<input id="fileInput" type="file" accept="video/*">
<div class="link-help">
Supports MP4, WebM, MOV, AVI, MKV, etc. (Max 2GB recommended)
</div>
</div>
<!-- Link Upload Tab -->
<div id="link-tab" class="tab-content">
<div class="link-input-container">
<input type="url" id="videoLink" class="link-input" placeholder="https://example.com/video.mp4">
<button id="loadLinkBtn" class="btn secondary">Load</button>
</div>
<div class="link-help">
Enter direct video link (ends with .mp4, .webm, etc.)<br>
<strong>‚ö†Ô∏è Note:</strong> Social media links (YouTube, Instagram, TikTok) require server-side processing.
</div>
</div>
<div class="performance-warning" id="performanceWarning">
‚ö†Ô∏è For better performance, keep video segments under 30 minutes.
</div>
<div id="audioStatus" class="audio-status" style="display:none;">
üîä Audio: Ready
</div>
<video id="player" controls preload="metadata" crossorigin="anonymous">Your browser doesn't support the video element.</video>

<!-- NEW: Timeline Control -->
<div class="timeline-container" id="timelineContainer">
<div class="timeline-controls">
<div class="segment-info">
<span>Segment: <span id="segmentTimeDisplay">0:00 - 0:00</span></span>
<span>Duration: <span id="segmentDurationDisplay">0:00</span></span>
</div>
<div class="segment-toggle">
<input type="checkbox" id="enableSegment" checked>
<label for="enableSegment">Enable segment selection</label>
</div>
</div>
<div class="timeline-track" id="timelineTrack">
<div class="timeline-progress" id="timelineProgress"></div>
<div class="timeline-segment" id="timelineSegment"></div>
<div class="segment-handle start" id="segmentStartHandle"></div>
<div class="segment-handle end" id="segmentEndHandle"></div>
<div class="timeline-seeker" id="timelineSeeker">
<div class="timeline-time-display" id="seekerTimeDisplay">0:00</div>
</div>
</div>
<button class="segment-reset-btn" id="resetSegmentBtn">Reset to Full Video</button>
<div id="fullVideoNotice" class="full-video-notice">
‚úÖ Full video will be processed (no segment selected)
</div>
</div>

<div class="controls-container">
<!-- Playback Controls -->
<div class="playback-controls">
<div class="time-with-percent">
<div class="time-display" id="currentTimeDisplay">0:00</div>
<div class="percentage-display" id="currentPercentDisplay">0%</div>
</div>
<div class="time-navigation">
<button class="nav-btn" id="jumpBack5" title="Jump back 5 seconds">-5s</button>
<button class="nav-btn" id="frameBack" title="Previous frame (‚Üê)">‚èÆ</button>
<button class="nav-btn" id="playPause" title="Play/Pause (Space)">‚ñ∂</button>
<button class="nav-btn" id="frameForward" title="Next frame (‚Üí)">‚è≠</button>
<button class="nav-btn" id="jumpForward5" title="Jump forward 5 seconds">+5s</button>
</div>
<div style="display:flex;gap:6px;margin-left:auto">
<button class="set-time-btn" id="setStartBtn" title="Set start to current time (S)">Set Start</button>
<button class="set-time-btn" id="setEndBtn" title="Set end to current time (E)">Set End</button>
</div>
</div>
<div class="keyboard-hint">
Shortcuts: <span class="keyboard-key">Space</span> Play/Pause ‚Ä¢
<span class="keyboard-key">‚Üê</span> <span class="keyboard-key">‚Üí</span> Frame step ‚Ä¢
<span class="keyboard-key">S</span> Set start ‚Ä¢
<span class="keyboard-key">E</span> Set end ‚Ä¢
<span class="keyboard-key">A</span> Extract Audio
</div>

<!-- Range Controls -->
<div class="range-controls">
<div class="range-group">
<span class="range-label">Start:</span>
<div class="range-wrapper">
<div class="range-with-percent">
<input id="startRange" type="range" min="0" max="0" step="0.001" value="0">
<div class="time-with-percent">
<input id="startInput" type="text" class="time-input" placeholder="0:00">
<div class="percentage-display" id="startPercentDisplay">0%</div>
</div>
</div>
</div>
</div>
<div class="range-group">
<span class="range-label">End:</span>
<div class="range-wrapper">
<div class="range-with-percent">
<input id="endRange" type="range" min="0" max="0" step="0.001" value="0">
<div class="time-with-percent">
<input id="endInput" type="text" class="time-input" placeholder="0:00">
<div class="percentage-display" id="endPercentDisplay">0%</div>
</div>
</div>
</div>
</div>
<!-- Percentage Input -->
<div class="field">
<label class="smallmuted">Set by Percentage</label>
<div class="percent-input-group">
<input id="startPercentInput" type="number" class="percent-input" placeholder="Start %" min="0" max="100" step="0.1">
<span class="smallmuted">‚Üí</span>
<input id="endPercentInput" type="number" class="percent-input" placeholder="End %" min="0" max="100" step="0.1">
<button id="applyPercentBtn" class="jump-btn">Apply %</button>
</div>
</div>
</div>

<!-- Audio Extract Section -->
<div class="audio-extract-container">
<div class="audio-extract-header">
<div class="audio-extract-title">üéµ Extract Audio Only</div>
<div class="audio-extract-controls">
<select id="audioFormatSelect" class="audio-format-selector">
<option value="mp3" selected>MP3 Format (Recommended)</option>
<option value="wav">WAV Format (Best Quality)</option>
<option value="ogg">OGG Format</option>
<option value="webm">WebM Audio</option>
</select>
<select id="audioQualitySelect" class="audio-quality-selector">
<option value="high">High Quality (320kbps)</option>
<option value="medium" selected>Medium (192kbps)</option>
<option value="low">Low (128kbps)</option>
</select>
<button id="extractAudioBtn" class="audio-extract-btn">
<span>üéµ</span> Extract Audio
</button>
</div>
</div>
<div class="smallmuted" style="font-size:11px;margin-top:4px;">
Extract audio from the selected segment. MP3 format is supported via JavaScript encoding.
</div>
<div id="audioFormatWarning" class="audio-format-warning" style="display:none;">
‚ö†Ô∏è Converting audio to MP3 format. This may take a moment for longer segments.
</div>
<div id="convertingProgress" class="converting-progress" style="display:none;">
üîÑ Converting to MP3: <span id="convertingPercent">0%</span>
</div>
</div>

<!-- Export Options -->
<div class="export-options">
<div class="option-group">
<label class="smallmuted">Video Quality:</label>
<select id="qualitySelect" class="quality-selector">
<option value="high">High Quality</option>
<option value="medium" selected>Medium (Recommended)</option>
<option value="low">Low (Fastest)</option>
</select>
<label class="smallmuted" style="margin-left:auto">
<input id="enableHardwareAccel" type="checkbox" checked>
Hardware Acceleration
</label>
</div>
<div class="option-group">
<label class="smallmuted">Selected Format: <span id="selectedFormatDisplay">WebM</span></label>
<div class="smallmuted" style="font-size:11px;color:var(--accent);">
‚ö° Long exports allowed but may take time
</div>
</div>
</div>

<!-- Captions Panel -->
<div class="captions-container">
<div class="captions-header">
<h3>üé§ Auto-Generated Captions</h3>
<div class="captions-controls">
<button id="generateCaptionsBtn" class="jump-btn">Generate</button>
<button id="clearCaptionsBtn" class="jump-btn">Clear</button>
<button id="exportCaptionsBtn" class="jump-btn">Export SRT</button>
</div>
</div>
<div class="captions-panel" id="captionsPanel">
<div class="no-captions">No captions generated yet. Click "Generate" to create captions from audio.</div>
</div>
</div>

<!-- Action Buttons -->
<div class="action-buttons">
<div style="display:flex;gap:8px">
<button id="previewBtn" class="btn secondary">
<span>üîç</span> Preview
</button>
<button id="trimBtn" class="btn">
<span>‚úÇÔ∏è</span> Export Video
</button>
</div>
<div class="duration-badge">
<span>Segment:</span>
<span class="highlight" id="segmentDuration">0.00s</span>
<span>|</span>
<span class="highlight" id="segmentPercent">0%</span>
<span>| Total:</span>
<span class="highlight" id="durationBadge">0s</span>
</div>
</div>
<progress id="progress" value="0" max="1" style="display:none"></progress>
<div class="export-progress-info" style="display:none" id="exportProgressInfo">
<span class="export-progress-percent" id="exportProgressPercent">0%</span>
<span class="export-progress-time" id="exportProgressTime">0:00 / 0:00</span>
</div>
<div id="errorMessage" class="smallmuted" style="color:#ef4444;margin-top:8px;display:none"></div>
<div id="status" class="smallmuted" style="margin-top:8px">No video loaded.</div>
</div>
</div>
</div>
<aside class="sidebar">
<div class="panel">
<div class="field">
<label class="smallmuted">Manual time entry</label>
<div style="display:flex;gap:6px">
<input id="manualStart" type="text" placeholder="0:00" style="flex:1;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit">
<input id="manualEnd" type="text" placeholder="0:00" style="flex:1;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit">
</div>
<button id="applyManualTimes" class="jump-btn" style="margin-top:6px;width:100%">Apply Manual Times</button>
</div>
<div class="field">
<label class="smallmuted">Quick Jumps</label>
<div style="display:flex;gap:6px;flex-wrap:wrap">
<button class="jump-btn" data-seconds="-10">-10s</button>
<button class="jump-btn" data-seconds="-5">-5s</button>
<button class="jump-btn" data-seconds="-1">-1s</button>
<button class="jump-btn" data-seconds="1">+1s</button>
<button class="jump-btn" data-seconds="5">+5s</button>
<button class="jump-btn" data-seconds="10">+10s</button>
</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:4px">
<button class="jump-btn" data-percent="-10">-10%</button>
<button class="jump-btn" data-percent="-5">-5%</button>
<button class="jump-btn" data-percent="5">+5%</button>
<button class="jump-btn" data-percent="10">+10%</button>
</div>
</div>
<div class="field">
<label class="smallmuted">Audio Settings</label>
<div style="display:flex;flex-direction:column;gap:8px">
<label style="display:flex;gap:6px;align-items:center">
<input id="muteCheckbox" type="checkbox">
<span class="smallmuted">Mute audio in export</span>
</label>
<!-- Volume Control -->
<div class="volume-controls">
<div class="volume-label">
<span>üîä Export Volume</span>
<span id="volumePercent">100%</span>
</div>
<div class="volume-slider-container">
<span style="color:var(--muted);font-size:12px;">Low</span>
<input type="range" id="volumeSlider" class="volume-slider" min="0" max="300" value="100" step="1">
<span style="color:var(--muted);font-size:12px;">Loud</span>
<div class="volume-value" id="volumeValue">1.0x</div>
</div>
<div class="volume-visualizer" id="volumeVisualizer"></div>
<div class="volume-presets">
<button class="volume-preset" data-volume="50">0.5x</button>
<button class="volume-preset" data-volume="100">1.0x</button>
<button class="volume-preset active" data-volume="150">1.5x</button>
<button class="volume-preset" data-volume="200">2.0x</button>
<button class="volume-preset" data-volume="300">3.0x</button>
</div>
<div id="audioTestBtn" style="display:none;">
<button class="jump-btn" id="testAudioBtn" style="width:100%;margin-top:4px">
üîä Test Audio
</button>
</div>
</div>
<label style="display:flex;gap:6px;align-items:center;margin-top:8px">
<input id="normalizeAudio" type="checkbox" checked>
<span class="smallmuted">Normalize audio (prevent clipping)</span>
</label>
</div>
</div>
<div class="field">
<label class="smallmuted">Video Settings</label>
<div style="display:flex;flex-direction:column;gap:8px">
<label style="display:flex;gap:6px;align-items:center">
<input id="resizeCheckbox" type="checkbox">
<span class="smallmuted">Resize to 720p</span>
</label>
<div>
<label class="smallmuted">Format:</label>
<div style="display:flex;gap:8px;margin-top:4px">
<label style="display:flex;gap:4px;align-items:center" class="format-option">
<input type="radio" name="format" value="webm" checked>
<span class="smallmuted">WebM (faster)</span>
</label>
<label style="display:flex;gap:4px;align-items:center" class="format-option">
<input type="radio" name="format" value="mp4">
<span class="smallmuted">MP4</span>
</label>
</div>
<div id="formatWarning" class="smallmuted" style="margin-top:4px;color:var(--warning);font-size:11px;display:none">
‚ö†Ô∏è MP4 may not be supported in some browsers. Using WebM instead.
</div>
</div>
<div class="smallmuted" style="margin-top:4px;color:#10b981;font-size:12px">
üîä Audio volume can be boosted up to 3x louder!
</div>
</div>
</div>
<div class="field">
<label class="smallmuted">Downloads</label>
<div id="downloads" class="download-list">
<div class="smallmuted" style="text-align:center;padding:20px;color:var(--muted);font-style:italic">
No exports yet. Export a video or audio to see it here.
</div>
</div>
</div>
</div>
<div class="panel">
<p class="smallmuted">‚ú® New Features</p>
<ul class="smallmuted">
<li><strong>Drag & Drop Timeline</strong>: Drag the seeker ball to navigate video</li>
<li><strong>Full Video Processing</strong>: Export entire video when no segment selected</li>
<li><strong>Segment Handles</strong>: Drag handles to adjust start/end points</li>
<li><strong>Direct Video Links</strong>: Load videos from any direct URL</li>
<li><strong>Auto-Captions</strong>: Generate captions using browser speech recognition</li>
<li><strong>Export SRT</strong>: Download captions as subtitle file</li>
<li><strong>Volume Boost</strong>: Amplify audio up to 3x</li>
<li><strong>Audio Extraction</strong>: Extract audio from video segments (MP3, WAV, OGG, WebM)</li>
<li><strong>Real MP3 Support</strong>: JavaScript encoding for true MP3 files</li>
<li><strong>Unlimited Downloads</strong>: Download videos and songs as many times as you want</li>
<li><strong>Fixed Duration Detection</strong>: Better handling of videos with problematic metadata</li>
</ul>
<p class="smallmuted" style="margin-top:8px;color:var(--warning);font-size:11px;">
‚ö†Ô∏è Social media links require a backend server. This works with direct video file URLs only.
</p>
</div>
</aside>
</div>
<footer class="note">For social media downloads, you'll need a server with appropriate APIs. Direct video links work immediately.</footer>
</div>
<script>
(function(){
// Elements
const fileInput = document.getElementById('fileInput');
const videoLink = document.getElementById('videoLink');
const loadLinkBtn = document.getElementById('loadLinkBtn');
const player = document.getElementById('player');
const startRange = document.getElementById('startRange');
const endRange = document.getElementById('endRange');
const startInput = document.getElementById('startInput');
const endInput = document.getElementById('endInput');
const manualStart = document.getElementById('manualStart');
const manualEnd = document.getElementById('manualEnd');
const startPercentInput = document.getElementById('startPercentInput');
const endPercentInput = document.getElementById('endPercentInput');
const applyPercentBtn = document.getElementById('applyPercentBtn');
const applyManualTimes = document.getElementById('applyManualTimes');
const currentTimeDisplay = document.getElementById('currentTimeDisplay');
const currentPercentDisplay = document.getElementById('currentPercentDisplay');
const startPercentDisplay = document.getElementById('startPercentDisplay');
const endPercentDisplay = document.getElementById('endPercentDisplay');
const segmentDuration = document.getElementById('segmentDuration');
const segmentPercent = document.getElementById('segmentPercent');
const startPercentText = document.getElementById('startPercentText');
const endPercentText = document.getElementById('endPercentText');
const segmentPercentText = document.getElementById('segmentPercentText');
const exportProgressInfo = document.getElementById('exportProgressInfo');
const exportProgressPercent = document.getElementById('exportProgressPercent');
const exportProgressTime = document.getElementById('exportProgressTime');
const errorMessage = document.getElementById('errorMessage');
const audioStatus = document.getElementById('audioStatus');
const fileSizeInfo = document.getElementById('fileSizeInfo');
const volumeSlider = document.getElementById('volumeSlider');
const volumeValue = document.getElementById('volumeValue');
const volumePercent = document.getElementById('volumePercent');
const volumeVisualizer = document.getElementById('volumeVisualizer');
const volumePresets = document.querySelectorAll('.volume-preset');
const normalizeAudio = document.getElementById('normalizeAudio');
const generateCaptionsBtn = document.getElementById('generateCaptionsBtn');
const clearCaptionsBtn = document.getElementById('clearCaptionsBtn');
const exportCaptionsBtn = document.getElementById('exportCaptionsBtn');
const captionsPanel = document.getElementById('captionsPanel');
const performanceWarning = document.getElementById('performanceWarning');
const qualitySelect = document.getElementById('qualitySelect');
const enableHardwareAccel = document.getElementById('enableHardwareAccel');
const selectedFormatDisplay = document.getElementById('selectedFormatDisplay');
const formatWarning = document.getElementById('formatWarning');
const audioFormatWarning = document.getElementById('audioFormatWarning');
const convertingProgress = document.getElementById('convertingProgress');
const convertingPercent = document.getElementById('convertingPercent');
const formatOptions = document.querySelectorAll('.format-option');

// NEW: Timeline elements
const timelineContainer = document.getElementById('timelineContainer');
const timelineTrack = document.getElementById('timelineTrack');
const timelineProgress = document.getElementById('timelineProgress');
const timelineSeeker = document.getElementById('timelineSeeker');
const seekerTimeDisplay = document.getElementById('seekerTimeDisplay');
const timelineSegment = document.getElementById('timelineSegment');
const segmentStartHandle = document.getElementById('segmentStartHandle');
const segmentEndHandle = document.getElementById('segmentEndHandle');
const resetSegmentBtn = document.getElementById('resetSegmentBtn');
const enableSegmentCheckbox = document.getElementById('enableSegment');
const fullVideoNotice = document.getElementById('fullVideoNotice');
const segmentTimeDisplay = document.getElementById('segmentTimeDisplay');
const segmentDurationDisplay = document.getElementById('segmentDurationDisplay');

// Audio extraction elements
const audioFormatSelect = document.getElementById('audioFormatSelect');
const audioQualitySelect = document.getElementById('audioQualitySelect');
const extractAudioBtn = document.getElementById('extractAudioBtn');

// Tab controls
const tabButtons = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');
const previewBtn = document.getElementById('previewBtn');
const trimBtn = document.getElementById('trimBtn');
const progressEl = document.getElementById('progress');
const status = document.getElementById('status');
const downloads = document.getElementById('downloads');
const durationBadge = document.getElementById('durationBadge');
const muteCheckbox = document.getElementById('muteCheckbox');
const resizeCheckbox = document.getElementById('resizeCheckbox');
const formatRadios = document.querySelectorAll('input[name="format"]');

// Enhanced controls
const playPauseBtn = document.getElementById('playPause');
const frameBackBtn = document.getElementById('frameBack');
const frameForwardBtn = document.getElementById('frameForward');
const jumpBack5Btn = document.getElementById('jumpBack5');
const jumpForward5Btn = document.getElementById('jumpForward5');
const setStartBtn = document.getElementById('setStartBtn');
const setEndBtn = document.getElementById('setEndBtn');
const quickJumpButtons = document.querySelectorAll('.jump-btn[data-seconds]');
const percentJumpButtons = document.querySelectorAll('.jump-btn[data-percent]');

// State
let fileURL = null;
let isPlaying = false;
let totalDuration = 0;
let currentFile = null;
let currentVolume = 1.0;
let captions = [];
let isGeneratingCaptions = false;
let speechRecognition = null;
let selectedFormat = 'webm'; // Default format

// NEW: Timeline state
let isDraggingSeeker = false;
let isDraggingStartHandle = false;
let isDraggingEndHandle = false;
let segmentEnabled = true;
let useFullVideo = false;

// Performance optimization
let animationFrameId = null;
let lastRenderTime = 0;
const targetFPS = 30;
const frameInterval = 1000 / targetFPS;
let isExporting = false;
let exportTimeout = null;

// Store exports for unlimited downloads
let exports = [];
let nextExportId = 1;

// Duration detection state
let isDurationDetectionActive = false;
let durationDetectionAttempts = 0;
const MAX_DURATION_DETECTION_ATTEMPTS = 5;

// Check if lamejs is available
let lamejsAvailable = false;
try {
if (typeof lamejs !== 'undefined') {
lamejsAvailable = true;
console.log('lamejs is available for MP3 encoding');
} else {
console.warn('lamejs not available, MP3 encoding will use fallback');
}
} catch (e) {
console.warn('lamejs not available:', e);
}

// Helper function for download
function forceDownload(url, filename) {
const a = document.createElement('a');
a.href = url;
a.download = filename;
a.style.display = 'none';
document.body.appendChild(a);
a.click();
// Clean up
setTimeout(() => {
document.body.removeChild(a);
}, 100);
}

// FIXED: Improved codec detection that respects user selection
function getSupportedMimeType(userFormat, quality = 'medium') {
const bitrates = {
'high': { video: 2500000, audio: 192000 },
'medium': { video: 1500000, audio: 128000 },
'low': { video: 750000, audio: 64000 }
};
const bitrate = bitrates[quality] || bitrates.medium;

// Always try to use the user's selected format first
const formatCodecs = {
'mp4': [
'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
'video/mp4;codecs=h264,aac',
'video/mp4;codecs=avc1,aac',
'video/mp4'
],
'webm': [
'video/webm;codecs=vp9,opus',
'video/webm;codecs=vp8,opus',
'video/webm'
]
};

// Check if user's selected format is supported
if (formatCodecs[userFormat]) {
for (const codec of formatCodecs[userFormat]) {
if (MediaRecorder.isTypeSupported(codec)) {
console.log(`User selected ${userFormat.toUpperCase()} supported: ${codec}`);
return { mimeType: codec, format: userFormat, supported: true };
}
}
}

// If user's selection is not supported, try alternative formats
console.log(`${userFormat.toUpperCase()} not supported, trying alternatives...`);

// Try WebM as fallback (most widely supported)
const webmCodecs = [
'video/webm;codecs=vp9,opus',
'video/webm;codecs=vp8,opus',
'video/webm'
];
for (const codec of webmCodecs) {
if (MediaRecorder.isTypeSupported(codec)) {
console.log(`Fallback to WebM: ${codec}`);
return { mimeType: codec, format: 'webm', supported: false };
}
}

// Last resort - try MP4
const mp4Codecs = [
'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
'video/mp4;codecs=h264,aac',
'video/mp4'
];
for (const codec of mp4Codecs) {
if (MediaRecorder.isTypeSupported(codec)) {
console.log(`Fallback to MP4: ${codec}`);
return { mimeType: codec, format: 'mp4', supported: false };
}
}

// If nothing works
return {
mimeType: userFormat === 'mp4' ? 'video/mp4' : 'video/webm',
format: userFormat,
supported: false
};
}

// Get audio MIME type based on selected format with browser compatibility check
function getAudioMimeType(audioFormat) {
    // For WAV format specifically
    if (audioFormat === 'wav') {
        // WAV is widely supported through MediaRecorder in most browsers
        return 'audio/wav';
    }
    
    // For MP3, we'll use WAV format as intermediate
    if (audioFormat === 'mp3') {
        return getSupportedAudioMimeType('wav');
    }

    // For other formats, try to find a supported format
    const audioFormats = [
        { format: 'wav', mime: 'audio/wav' },
        { format: 'ogg', mime: 'audio/ogg;codecs=opus' },
        { format: 'webm', mime: 'audio/webm;codecs=opus' }
    ];

    // Try to find a supported format
    for (const format of audioFormats) {
        if (format.format === audioFormat) {
            // For WAV, we'll use it even if MediaRecorder doesn't report support
            if (format.format === 'wav') {
                return 'audio/wav';
            }
            
            if (MediaRecorder.isTypeSupported(format.mime)) {
                console.log(`Audio format ${audioFormat} supported: ${format.mime}`);
                return format.mime;
            }
        }
    }

    // Default to WAV if nothing else works or if we specifically want WAV
    console.log('Using WAV audio format');
    return 'audio/wav';
}

// Helper function to get supported audio MIME type
function getSupportedAudioMimeType(preferredFormat) {
const formats = [
{ format: 'wav', mime: 'audio/wav' },
{ format: 'ogg', mime: 'audio/ogg;codecs=opus' },
{ format: 'webm', mime: 'audio/webm;codecs=opus' }
];

// Try preferred format first
for (const format of formats) {
if (format.format === preferredFormat && MediaRecorder.isTypeSupported(format.mime)) {
return format.mime;
}
}

// Try any supported format
for (const format of formats) {
if (MediaRecorder.isTypeSupported(format.mime)) {
return format.mime;
}
}

// Default
return 'audio/wav';
}

// Get audio bitrate based on quality
function getAudioBitrate(quality, format = 'mp3') {
if (format === 'mp3') {
const mp3Bitrates = {
'high': 320,
'medium': 192,
'low': 128
};
return mp3Bitrates[quality] || 192;
} else {
const bitrates = {
'high': 256000,
'medium': 128000,
'low': 64000
};
return bitrates[quality] || 128000;
}
}

// Optimized time formatting with hours support
function formatTime(seconds) {
if (!isFinite(seconds) || isNaN(seconds)) return '0:00';
const hrs = Math.floor(seconds / 3600);
const mins = Math.floor((seconds % 3600) / 60);
const secs = Math.floor(seconds % 60);
if (hrs > 0) {
return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}
return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function parseTimeInput(input) {
if (!input || input.trim() === '') return 0;
const str = input.trim();
if (str.includes(':')) {
const parts = str.split(':');
let seconds = 0;
if (parts.length === 3) {
seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
} else if (parts.length === 2) {
seconds = parseInt(parts[0]) * 60 + parseFloat(parts[1]);
} else {
seconds = parseFloat(parts[0]);
}
return seconds;
}
const num = parseFloat(str);
return isNaN(num) ? 0 : num;
}

// Function to convert AudioBuffer to WAV
function audioBufferToWav(buffer, volume = 1.0) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const length = buffer.length;
    
    // Create interleaved PCM data
    const interleaved = new Float32Array(length * numChannels);
    for (let channel = 0; channel < numChannels; channel++) {
        const channelData = buffer.getChannelData(channel);
        for (let i = 0; i < length; i++) {
            interleaved[i * numChannels + channel] = channelData[i] * volume;
        }
    }
    
    // Convert to 16-bit PCM
    const pcm16 = new Int16Array(interleaved.length);
    for (let i = 0; i < interleaved.length; i++) {
        const s = Math.max(-1, Math.min(1, interleaved[i]));
        pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    
    // Create WAV header
    const wavHeader = new ArrayBuffer(44);
    const view = new DataView(wavHeader);
    
    // RIFF identifier
    writeString(view, 0, 'RIFF');
    // File length
    view.setUint32(4, 36 + pcm16.length * 2, true);
    // RIFF type
    writeString(view, 8, 'WAVE');
    // Format chunk identifier
    writeString(view, 12, 'fmt ');
    // Format chunk length
    view.setUint32(16, 16, true);
    // Sample format (PCM)
    view.setUint16(20, 1, true);
    // Channel count
    view.setUint16(22, numChannels, true);
    // Sample rate
    view.setUint32(24, sampleRate, true);
    // Byte rate (sample rate * block align)
    view.setUint32(28, sampleRate * numChannels * 2, true);
    // Block align (channel count * bytes per sample)
    view.setUint16(32, numChannels * 2, true);
    // Bits per sample
    view.setUint16(34, 16, true);
    // Data chunk identifier
    writeString(view, 36, 'data');
    // Data chunk length
    view.setUint32(40, pcm16.length * 2, true);
    
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    
    // Combine header and PCM data
    const wavBlob = new Blob([wavHeader, pcm16], { type: 'audio/wav' });
    return wavBlob;
}

// IMPROVED: Enhanced duration detection with multiple fallback methods
function getVideoDurationWithFallback(videoElement) {
    let duration = 0;
    
    // Method 1: Direct duration property
    if (videoElement.duration && videoElement.duration > 0 && videoElement.duration !== Infinity) {
        duration = videoElement.duration;
        console.log('Duration from video.duration:', duration);
        return duration;
    }
    
    // Method 2: Seekable end
    if (videoElement.seekable && videoElement.seekable.length > 0) {
        const seekableEnd = videoElement.seekable.end(videoElement.seekable.length - 1);
        if (seekableEnd && seekableEnd > 0) {
            duration = seekableEnd;
            console.log('Duration from video.seekable.end:', duration);
            return duration;
        }
    }
    
    // Method 3: Buffered end
    if (videoElement.buffered && videoElement.buffered.length > 0) {
        const bufferedEnd = videoElement.buffered.end(videoElement.buffered.length - 1);
        if (bufferedEnd && bufferedEnd > 0) {
            duration = bufferedEnd;
            console.log('Duration from video.buffered.end:', duration);
            return duration;
        }
    }
    
    // Method 4: Try to get duration via video tracks
    if (videoElement.videoTracks && videoElement.videoTracks.length > 0) {
        const track = videoElement.videoTracks[0];
        if (track && track.length && track.length > 0) {
            duration = track.length;
            console.log('Duration from videoTracks[0].length:', duration);
            return duration;
        }
    }
    
    // Method 5: Try to seek to end and get time
    // This is a more aggressive method for problematic videos
    return new Promise((resolve) => {
        const tempVideo = videoElement.cloneNode();
        tempVideo.currentTime = Number.MAX_SAFE_INTEGER;
        
        tempVideo.onseeked = () => {
            if (tempVideo.duration && tempVideo.duration > 0 && tempVideo.duration !== Infinity) {
                duration = tempVideo.duration;
                console.log('Duration from seek to end:', duration);
            }
            resolve(duration);
        };
        
        tempVideo.onerror = () => {
            console.warn('Failed to get duration via seeking');
            resolve(duration);
        };
        
        // Timeout for seeking
        setTimeout(() => {
            if (tempVideo.duration && tempVideo.duration > 0) {
                duration = tempVideo.duration;
                console.log('Duration after timeout:', duration);
            }
            resolve(duration);
        }, 2000);
    });
}

// NEW: Advanced duration detection with multiple attempts
async function detectVideoDuration(videoElement) {
    if (isDurationDetectionActive) return totalDuration;
    
    isDurationDetectionActive = true;
    durationDetectionAttempts = 0;
    
    // Try multiple methods in sequence
    const detectionMethods = [
        // Method 1: Direct property
        () => {
            if (videoElement.duration && videoElement.duration > 0 && videoElement.duration !== Infinity) {
                return videoElement.duration;
            }
            return 0;
        },
        
        // Method 2: Wait a bit and try again (some videos load metadata slowly)
        () => {
            return new Promise(resolve => {
                setTimeout(() => {
                    if (videoElement.duration && videoElement.duration > 0 && videoElement.duration !== Infinity) {
                        resolve(videoElement.duration);
                    } else {
                        resolve(0);
                    }
                }, 500);
            });
        },
        
        // Method 3: Check seekable ranges
        () => {
            if (videoElement.seekable && videoElement.seekable.length > 0) {
                const seekableEnd = videoElement.seekable.end(videoElement.seekable.length - 1);
                if (seekableEnd && seekableEnd > 0) {
                    return seekableEnd;
                }
            }
            return 0;
        },
        
        // Method 4: Check buffered ranges
        () => {
            if (videoElement.buffered && videoElement.buffered.length > 0) {
                const bufferedEnd = videoElement.buffered.end(videoElement.buffered.length - 1);
                if (bufferedEnd && bufferedEnd > 0) {
                    return bufferedEnd;
                }
            }
            return 0;
        },
        
        // Method 5: Try to play and seek
        () => {
            return new Promise(resolve => {
                const wasPlaying = !videoElement.paused;
                const wasMuted = videoElement.muted;
                const currentTime = videoElement.currentTime;
                
                // Save current state
                videoElement.muted = true;
                
                // Try to seek near the end
                videoElement.currentTime = 3600; // 1 hour
                
                const onSeeked = () => {
                    videoElement.removeEventListener('seeked', onSeeked);
                    videoElement.removeEventListener('error', onError);
                    
                    // Try to get duration after seeking
                    setTimeout(() => {
                        let detectedDuration = 0;
                        
                        if (videoElement.duration && videoElement.duration > 0 && videoElement.duration !== Infinity) {
                            detectedDuration = videoElement.duration;
                        } else if (videoElement.seekable && videoElement.seekable.length > 0) {
                            detectedDuration = videoElement.seekable.end(videoElement.seekable.length - 1);
                        }
                        
                        // Restore original state
                        videoElement.currentTime = currentTime;
                        videoElement.muted = wasMuted;
                        if (!wasPlaying) {
                            videoElement.pause();
                        }
                        
                        resolve(detectedDuration);
                    }, 100);
                };
                
                const onError = () => {
                    videoElement.removeEventListener('seeked', onSeeked);
                    videoElement.removeEventListener('error', onError);
                    
                    // Restore original state
                    videoElement.currentTime = currentTime;
                    videoElement.muted = wasMuted;
                    if (!wasPlaying) {
                        videoElement.pause();
                    }
                    
                    resolve(0);
                };
                
                videoElement.addEventListener('seeked', onSeeked);
                videoElement.addEventListener('error', onError);
                
                // Timeout
                setTimeout(() => {
                    videoElement.removeEventListener('seeked', onSeeked);
                    videoElement.removeEventListener('error', onError);
                    
                    // Restore original state
                    videoElement.currentTime = currentTime;
                    videoElement.muted = wasMuted;
                    if (!wasPlaying) {
                        videoElement.pause();
                    }
                    
                    resolve(0);
                }, 3000);
            });
        }
    ];
    
    // Try each method until we get a valid duration
    for (let i = 0; i < detectionMethods.length; i++) {
        durationDetectionAttempts++;
        
        try {
            const method = detectionMethods[i];
            let result;
            
            if (typeof method === 'function') {
                result = method();
                
                // Handle promises
                if (result && typeof result.then === 'function') {
                    result = await result;
                }
                
                if (result && result > 0) {
                    totalDuration = result;
                    console.log(`Duration detected via method ${i + 1}: ${formatTime(result)}`);
                    isDurationDetectionActive = false;
                    return result;
                }
            }
        } catch (error) {
            console.warn(`Duration detection method ${i + 1} failed:`, error);
        }
        
        // Wait a bit between attempts
        if (i < detectionMethods.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }
    
    // Last resort: If we can't detect duration, estimate based on file size
    if (currentFile && currentFile.size > 0 && totalDuration <= 0) {
        // Rough estimation: 1MB ‚âà 5-10 seconds of video (varies by quality)
        // This is a very rough estimate but better than 0
        const estimatedDuration = Math.min((currentFile.size / (1024 * 1024)) * 7, 3600); // Max 1 hour
        totalDuration = estimatedDuration;
        console.log(`Estimated duration from file size: ${formatTime(estimatedDuration)}`);
        status.textContent = `‚ö†Ô∏è Duration estimated: ${formatTime(estimatedDuration)} (metadata incomplete)`;
    }
    
    isDurationDetectionActive = false;
    return totalDuration;
}

// NEW: Force duration detection for problematic videos
async function forceDurationDetection() {
    if (isDurationDetectionActive) return;
    
    status.textContent = 'Detecting video duration...';
    console.log('Starting forced duration detection');
    
    const detectedDuration = await detectVideoDuration(player);
    
    if (detectedDuration > 0) {
        totalDuration = detectedDuration;
        initializeDurationControls();
        status.textContent = `Video loaded: ${formatTime(totalDuration)}`;
        updateAudioStatus(`Ready`, 'ready');
    } else {
        // If still no duration, use a default
        totalDuration = 300; // Default to 5 minutes
        initializeDurationControls();
        status.textContent = '‚ö†Ô∏è Using default duration (5 min). Manual time entry recommended.';
        updateAudioStatus(`Duration estimated`, 'warning');
    }
}

// Function to initialize duration controls
function initializeDurationControls() {
    if (totalDuration <= 0) {
        console.warn('Cannot initialize controls with duration <= 0');
        return;
    }
    
    // Set up range controls
    startRange.min = 0;
    startRange.max = totalDuration;
    startRange.value = 0;
    endRange.min = 0;
    endRange.max = totalDuration;
    endRange.value = totalDuration;
    
    // Format times
    const startTime = 0;
    const endTime = totalDuration;
    startInput.value = formatTime(startTime);
    endInput.value = formatTime(endTime);
    manualStart.value = formatTime(startTime);
    manualEnd.value = formatTime(endTime);
    durationBadge.textContent = `${Math.floor(totalDuration)}s (${formatTime(totalDuration)})`;
    
    // Use requestAnimationFrame for smoother updates
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    function smoothUpdate() {
        updateTimeDisplay();
        updateAllPercentages();
        updateTimeline();
        animationFrameId = requestAnimationFrame(smoothUpdate);
    }
    smoothUpdate();
    
    updateSegmentDuration();
    
    if (totalDuration > 0) {
        updateAudioStatus(`Ready`, 'ready');
    }
}

// NEW: Timeline functions
function updateTimeline() {
if (!totalDuration || totalDuration === 0) return;
const currentTime = player.currentTime;
const currentPercent = (currentTime / totalDuration) * 100;
const startTime = parseFloat(startRange.value) || 0;
const endTime = parseFloat(endRange.value) || totalDuration;
const startPercent = (startTime / totalDuration) * 100;
const endPercent = (endTime / totalDuration) * 100;

// Update progress
timelineProgress.style.width = `${currentPercent}%`;

// Update seeker position
timelineSeeker.style.left = `${currentPercent}%`;

// Update segment
if (segmentEnabled && !useFullVideo) {
timelineSegment.style.left = `${startPercent}%`;
timelineSegment.style.width = `${endPercent - startPercent}%`;
segmentStartHandle.style.left = `${startPercent}%`;
segmentEndHandle.style.left = `${endPercent}%`;
segmentStartHandle.style.display = 'block';
segmentEndHandle.style.display = 'block';
timelineSegment.style.display = 'block';
} else {
timelineSegment.style.display = 'none';
segmentStartHandle.style.display = 'none';
segmentEndHandle.style.display = 'none';
}

// Update seeker time display
seekerTimeDisplay.textContent = formatTime(currentTime);
seekerTimeDisplay.style.left = `${currentPercent}%`;

// Update segment display
segmentTimeDisplay.textContent = `${formatTime(startTime)} - ${formatTime(endTime)}`;
segmentDurationDisplay.textContent = formatTime(endTime - startTime);

// Update full video notice
if (useFullVideo || !segmentEnabled) {
fullVideoNotice.classList.add('active');
fullVideoNotice.textContent = '‚úÖ Full video will be processed (no segment selected)';
} else {
fullVideoNotice.classList.remove('active');
}
}

function handleTimelineClick(e) {
if (!totalDuration || totalDuration === 0) return;
const rect = timelineTrack.getBoundingClientRect();
const x = e.clientX - rect.left;
const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
const time = (percent / 100) * totalDuration;
player.currentTime = time;
}

function handleSeekerDrag(e) {
if (!totalDuration || totalDuration === 0) return;
const rect = timelineTrack.getBoundingClientRect();
const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
const percent = (x / rect.width) * 100;
const time = (percent / 100) * totalDuration;
player.currentTime = time;
updateTimeline();
}

function handleStartHandleDrag(e) {
if (!totalDuration || totalDuration === 0) return;
const rect = timelineTrack.getBoundingClientRect();
const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
const percent = (x / rect.width) * 100;
const time = (percent / 100) * totalDuration;
const endTime = parseFloat(endRange.value) || totalDuration;
const newStartTime = Math.min(time, endTime - 0.1);
startRange.value = newStartTime;
syncFromRanges();
}

function handleEndHandleDrag(e) {
if (!totalDuration || totalDuration === 0) return;
const rect = timelineTrack.getBoundingClientRect();
const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
const percent = (x / rect.width) * 100;
const time = (percent / 100) * totalDuration;
const startTime = parseFloat(startRange.value) || 0;
const newEndTime = Math.max(time, startTime + 0.1);
endRange.value = Math.min(newEndTime, totalDuration);
syncFromRanges();
}

function setupTimeline() {
// Mouse events for timeline track
timelineTrack.addEventListener('click', handleTimelineClick);

// Drag events for seeker
timelineSeeker.addEventListener('mousedown', (e) => {
e.preventDefault();
isDraggingSeeker = true;
document.addEventListener('mousemove', handleSeekerDragMouse);
document.addEventListener('mouseup', () => {
isDraggingSeeker = false;
document.removeEventListener('mousemove', handleSeekerDragMouse);
});
});

function handleSeekerDragMouse(e) {
if (isDraggingSeeker) {
handleSeekerDrag(e);
}
}

// Touch events for mobile
timelineSeeker.addEventListener('touchstart', (e) => {
e.preventDefault();
isDraggingSeeker = true;
document.addEventListener('touchmove', handleSeekerDragTouch);
document.addEventListener('touchend', () => {
isDraggingSeeker = false;
document.removeEventListener('touchmove', handleSeekerDragTouch);
});
});

function handleSeekerDragTouch(e) {
if (isDraggingSeeker && e.touches.length > 0) {
handleSeekerDrag(e.touches[0]);
}
}

// Drag events for start handle
segmentStartHandle.addEventListener('mousedown', (e) => {
e.preventDefault();
isDraggingStartHandle = true;
document.addEventListener('mousemove', handleStartHandleDragMouse);
document.addEventListener('mouseup', () => {
isDraggingStartHandle = false;
document.removeEventListener('mousemove', handleStartHandleDragMouse);
});
});

function handleStartHandleDragMouse(e) {
if (isDraggingStartHandle) {
handleStartHandleDrag(e);
}
}

// Drag events for end handle
segmentEndHandle.addEventListener('mousedown', (e) => {
e.preventDefault();
isDraggingEndHandle = true;
document.addEventListener('mousemove', handleEndHandleDragMouse);
document.addEventListener('mouseup', () => {
isDraggingEndHandle = false;
document.removeEventListener('mousemove', handleEndHandleDragMouse);
});
});

function handleEndHandleDragMouse(e) {
if (isDraggingEndHandle) {
handleEndHandleDrag(e);
}
}

// Reset segment button
resetSegmentBtn.addEventListener('click', () => {
startRange.value = 0;
endRange.value = totalDuration || 0;
syncFromRanges();
useFullVideo = false;
updateTimeline();
status.textContent = 'Segment reset to full video';
});

// Segment toggle
enableSegmentCheckbox.addEventListener('change', () => {
segmentEnabled = enableSegmentCheckbox.checked;
useFullVideo = !segmentEnabled;
updateTimeline();
if (!segmentEnabled) {
status.textContent = 'Full video processing enabled';
} else {
status.textContent = 'Segment processing enabled';
}
});
}

// Performance optimized update functions
function updateTimeDisplay() {
const currentTime = Math.floor(player.currentTime * 10) / 10; // Reduce precision for performance
currentTimeDisplay.textContent = formatTime(currentTime);
if (totalDuration > 0) {
const currentPercent = Math.min(100, Math.max(0, (currentTime / totalDuration) * 100));
currentPercentDisplay.textContent = `${currentPercent.toFixed(1)}%`;
}
}

function updateAllPercentages() {
if (!totalDuration || totalDuration === 0) return;
const currentTime = player.currentTime;
const startTime = parseFloat(startRange.value);
const endTime = parseFloat(endRange.value);
const currentPercent = (currentTime / totalDuration) * 100;
currentPercentDisplay.textContent = `${currentPercent.toFixed(1)}%`;
const startPercent = (startTime / totalDuration) * 100;
const endPercent = (endTime / totalDuration) * 100;
startPercentDisplay.textContent = `${startPercent.toFixed(1)}%`;
endPercentDisplay.textContent = `${endPercent.toFixed(1)}%`;
startPercentText.textContent = `${startPercent.toFixed(1)}%`;
endPercentText.textContent = `${endPercent.toFixed(1)}%`;
const segmentPercentValue = endPercent - startPercent;
segmentPercent.textContent = `${segmentPercentValue.toFixed(1)}%`;
segmentPercentText.textContent = `${segmentPercentValue.toFixed(1)}%`;
startPercentInput.value = startPercent.toFixed(1);
endPercentInput.value = endPercent.toFixed(1);
}

function updateSegmentDuration() {
const start = parseFloat(startRange.value) || 0;
const end = parseFloat(endRange.value) || totalDuration || 0;
const duration = Math.max(0, end - start);
segmentDuration.textContent = `${duration.toFixed(2)}s`;
if (totalDuration > 0) {
const segmentPercent = (duration / totalDuration) * 100;
segmentPercent.textContent = `${segmentPercent.toFixed(1)}%`;
}

// Show warning for very long segments
if (duration > 1800) { // 30 minutes
performanceWarning.style.display = 'block';
performanceWarning.textContent = `‚ö†Ô∏è Segment is ${formatTime(duration)}. This may take a while to export.`;
} else if (duration > 600) { // 10 minutes
performanceWarning.style.display = 'block';
performanceWarning.textContent = `‚ö†Ô∏è Segment is ${formatTime(duration)}. Export may be slow.`;
} else {
performanceWarning.style.display = 'none';
}
}

// Optimized volume control
function updateVolumeDisplay() {
const volume = parseInt(volumeSlider.value);
currentVolume = volume / 100;
volumeValue.textContent = `${currentVolume.toFixed(1)}x`;
volumePercent.textContent = `${volume}%`;
const percent = Math.min(100, volume / 3);
volumeVisualizer.style.setProperty('--volume-percent', `${percent}%`);
volumePresets.forEach(preset => {
if (parseInt(preset.dataset.volume) === volume) {
preset.classList.add('active');
} else {
preset.classList.remove('active');
}
});
}

// Error handling
function showError(message) {
errorMessage.textContent = message;
errorMessage.style.display = 'block';
}

function hideError() {
errorMessage.style.display = 'none';
}

function updateAudioStatus(message, type = 'ready') {
audioStatus.textContent = `üîä ${message}`;
audioStatus.className = `audio-status ${type}`;
audioStatus.style.display = 'flex';
}

// Ê∏ÖÁêÜ‰∏¥Êó∂ÂÖÉÁ¥†
function cleanupTemporaryElements() {
// Êü•ÊâæÂπ∂ÁßªÈô§ÊâÄÊúâÈöêËóèÁöÑ‰∏¥Êó∂video/canvasÂÖÉÁ¥†
const tempElements = document.querySelectorAll('video[style*="display: none"], canvas[style*="display: none"]');
tempElements.forEach(el => {
if (el.parentNode) {
el.parentNode.removeChild(el);
}
});
// Âº∫Âà∂ÂûÉÂúæÂõûÊî∂ÊèêÁ§∫ÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
if (window.gc) {
window.gc();
}
}

// Ê∏ÖÁêÜÊóßÁöÑÂØºÂá∫Êï∞ÊçÆ
function cleanupOldExports(currentId) {
// Âè™‰øùÁïôÊúÄËøëÁöÑ8‰∏™ÂØºÂá∫
if (exports.length > 8) {
const oldExports = exports.slice(0, -8);
oldExports.forEach(exp => {
if (exp.id !== currentId) {
// Ê∏ÖÁêÜBlobÂºïÁî®
exp.blob = null;
}
});
// ‰ªéÊï∞ÁªÑ‰∏≠ÁßªÈô§
exports = exports.slice(-8);
// Ê∏ÖÁêÜDOM‰∏≠ÁöÑ‰∏ãËΩΩÂÆπÂô®
const downloadContainers = downloads.querySelectorAll('.download-container');
if (downloadContainers.length > 8) {
for (let i = 0; i < downloadContainers.length - 8; i++) {
downloadContainers[i].remove();
}
}
}
}

// ÂÜÖÂ≠òÁõëÊéß
function startMemoryMonitor() {
if (performance && performance.memory) {
setInterval(() => {
const memory = performance.memory;
const usedMB = Math.round(memory.usedJSHeapSize / 1048576);
const totalMB = Math.round(memory.totalJSHeapSize / 1048576);
if (usedMB > 200) { // Â¶ÇÊûú‰ΩøÁî®Ë∂ÖËøá200MB
console.warn(`High memory usage: ${usedMB}MB/${totalMB}MB`);
// ÊòæÁ§∫Ë≠¶Âëä
if (!document.getElementById('memoryWarning')) {
const warning = document.createElement('div');
warning.id = 'memoryWarning';
warning.className = 'memory-warning';
warning.innerHTML = `‚ö†Ô∏è High memory usage (${usedMB}MB). Close other tabs or restart the page.`;
status.parentNode.insertBefore(warning, status.nextSibling);
// Ëá™Âä®Ê∏ÖÁêÜÊóßÁöÑÂØºÂá∫Êï∞ÊçÆ
cleanupOldExports();
}
} else {
const warning = document.getElementById('memoryWarning');
if (warning) {
warning.remove();
}
}
}, 10000); // ÊØè10ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
}
}

// ÂØºÂá∫ÂÆåÊàêÊèêÁ§∫
function showExportCompleteMessage() {
const completeMsg = document.createElement('div');
completeMsg.className = 'export-complete';
completeMsg.innerHTML = '‚úÖ Export complete! Page is ready for next operation.';
status.parentNode.insertBefore(completeMsg, status.nextSibling);
// 5ÁßíÂêéÁßªÈô§Ê∂àÊÅØ
setTimeout(() => {
if (completeMsg.parentNode) {
completeMsg.parentNode.removeChild(completeMsg);
}
}, 5000);
}

// Function to convert WAV to MP3 using lamejs
async function convertWavToMp3(wavBlob, bitrate = 192) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = async function(e) {
try {
const arrayBuffer = e.target.result;
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
const samples = audioBuffer.getChannelData(0); // Get first channel
const sampleRate = audioBuffer.sampleRate;
const numChannels = audioBuffer.numberOfChannels;

// If we have multiple channels, mix them down to mono for MP3
let mixedSamples;
if (numChannels > 1) {
const channel2 = audioBuffer.getChannelData(1);
mixedSamples = new Float32Array(samples.length);
for (let i = 0; i < samples.length; i++) {
mixedSamples[i] = (samples[i] + channel2[i]) / 2;
}
} else {
mixedSamples = samples;
}

// Convert float samples to 16-bit integers
const intSamples = new Int16Array(mixedSamples.length);
for (let i = 0; i < mixedSamples.length; i++) {
let s = Math.max(-1, Math.min(1, mixedSamples[i]));
intSamples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
}

// Use lamejs to encode to MP3
if (lamejsAvailable) {
const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, bitrate);
const sampleBlockSize = 1152;
const mp3Data = [];
for (let i = 0; i < intSamples.length; i += sampleBlockSize) {
const sampleChunk = intSamples.subarray(i, i + sampleBlockSize);
const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
if (mp3buf.length > 0) {
mp3Data.push(mp3buf);
}
// Update conversion progress
if (i % (sampleBlockSize * 100) === 0) {
const progress = (i / intSamples.length) * 100;
convertingPercent.textContent = `${progress.toFixed(1)}%`;
}
}
// Get remaining MP3 data
const mp3buf = mp3encoder.flush();
if (mp3buf.length > 0) {
mp3Data.push(mp3buf);
}
// Combine all MP3 data
const combined = new Uint8Array(mp3Data.reduce((a, b) => a + b.length, 0));
let offset = 0;
for (const chunk of mp3Data) {
combined.set(chunk, offset);
offset += chunk.length;
}
// Create MP3 blob
const mp3Blob = new Blob([combined], { type: 'audio/mpeg' });
audioContext.close();
resolve(mp3Blob);
} else {
// If lamejs is not available, return the WAV blob with .mp3 extension
console.warn('lamejs not available, returning WAV as MP3');
audioContext.close();
resolve(wavBlob);
}
} catch (error) {
reject(error);
}
};
reader.onerror = reject;
reader.readAsArrayBuffer(wavBlob);
});
}

// Function to convert audio to MP3 (optimized for performance)
async function convertAudioToMp3(audioBlob, originalFormat, bitrate) {
// Show conversion progress
convertingProgress.style.display = 'block';
convertingPercent.textContent = '0%';
audioFormatWarning.style.display = 'block';
audioFormatWarning.textContent = `‚ö†Ô∏è Converting ${originalFormat.toUpperCase()} to MP3 format. This may take a moment...`;

try {
let wavBlob = audioBlob;
// If not already WAV, we need to convert
if (originalFormat !== 'wav') {
// For now, we'll use the original blob and just change extension
// In a production app, you'd want to properly convert here
console.log(`Converting ${originalFormat} to MP3 (simulated)`);
// Simulate conversion time
await new Promise(resolve => setTimeout(resolve, 500));
}

// Convert WAV to MP3
const mp3Blob = await convertWavToMp3(wavBlob, bitrate);

// Hide progress
convertingProgress.style.display = 'none';
audioFormatWarning.style.display = 'none';
return mp3Blob;
} catch (error) {
console.error('MP3 conversion error:', error);
convertingProgress.style.display = 'none';
audioFormatWarning.style.display = 'block';
audioFormatWarning.textContent = '‚ö†Ô∏è MP3 conversion failed. Using original format instead.';
// Return original blob if conversion fails
return audioBlob;
}
}

// Initialize the app
function initializeApp() {
if (!window.MediaRecorder) {
showError('MediaRecorder API not supported in this browser. Try Chrome, Firefox, or Edge.');
trimBtn.disabled = true;
trimBtn.textContent = 'Not Supported';
extractAudioBtn.disabled = true;
extractAudioBtn.textContent = 'Not Supported';
}

// Hide warnings initially
audioFormatWarning.style.display = 'none';
convertingProgress.style.display = 'none';

// Set initial format display
updateFormatDisplay();

// Add format change listeners
formatRadios.forEach(radio => {
radio.addEventListener('change', (e) => {
selectedFormat = e.target.value;
updateFormatDisplay();
// Test if the selected format is supported
const testResult = getSupportedMimeType(selectedFormat, qualitySelect.value);
if (!testResult.supported && selectedFormat === 'mp4') {
formatWarning.style.display = 'block';
formatWarning.textContent = '‚ö†Ô∏è MP4 may not be fully supported in this browser. WebM will be used as fallback.';
} else {
formatWarning.style.display = 'none';
}
});
});

// Setup timeline
setupTimeline();

hideError();
updateVolumeDisplay();
startMemoryMonitor();
}

function updateFormatDisplay() {
const selectedRadio = document.querySelector('input[name="format"]:checked');
selectedFormat = selectedRadio ? selectedRadio.value : 'webm';
selectedFormatDisplay.textContent = selectedFormat.toUpperCase();

// Highlight the selected format option
formatOptions.forEach(option => {
const radio = option.querySelector('input[type="radio"]');
if (radio.checked) {
option.classList.add('format-highlight');
} else {
option.classList.remove('format-highlight');
}
});
}

// Tab switching
tabButtons.forEach(button => {
button.addEventListener('click', () => {
const tabId = button.dataset.tab;
tabButtons.forEach(btn => btn.classList.remove('active'));
button.classList.add('active');
tabContents.forEach(content => {
content.classList.remove('active');
if (content.id === tabId) {
content.classList.add('active');
}
});
if (tabId === 'link-tab') {
fileInput.value = '';
}
});
});

// Load video from URL
loadLinkBtn.addEventListener('click', async () => {
const url = videoLink.value.trim();
if (!url) {
showError('Please enter a video URL');
return;
}
try {
new URL(url);
} catch (e) {
showError('Please enter a valid URL (including http:// or https://)');
return;
}
status.textContent = 'Loading video from URL...';
hideError();
try {
const testResponse = await fetch(url, {
method: 'HEAD',
mode: 'cors'
}).catch(() => null);
if (fileURL) {
URL.revokeObjectURL(fileURL);
}
player.src = url;
player.load();
const fileName = url.split('/').pop().split('?')[0] || 'video_from_url';
currentFile = { name: fileName, size: 0 };
fileSizeInfo.textContent = 'From URL';
status.textContent = 'Video loaded from URL. Loading metadata...';
updateAudioStatus('Ready', 'ready');
} catch (error) {
console.error('Error loading video URL:', error);
showError('Failed to load video. Try downloading and uploading instead.');
status.textContent = 'Failed to load video';
}
});

// File handling
fileInput.addEventListener('change', async ()=>{
const f = fileInput.files && fileInput.files[0];
if(!f) return;
currentFile = f;
const fileSizeMB = f.size / 1024 / 1024;
fileSizeInfo.textContent = `${fileSizeMB.toFixed(1)} MB`;
if(fileURL) URL.revokeObjectURL(fileURL);
fileURL = URL.createObjectURL(f);
player.src = fileURL;
player.load();
status.textContent = `Loaded: ${f.name}`;
downloads.innerHTML = '<div class="smallmuted" style="text-align:center;padding:20px;color:var(--muted);font-style:italic">No exports yet. Export a video or audio to see it here.</div>';
isPlaying = false;
playPauseBtn.textContent = '‚ñ∂';
clearCaptions();
updateAudioStatus(`Ready`, 'ready');
hideError();
});

// IMPROVED: Video event handlers with robust duration detection
player.addEventListener('loadedmetadata', () => {
    console.log('loadedmetadata event fired');
    
    // Try to get duration immediately
    if (player.duration && player.duration > 0 && player.duration !== Infinity) {
        totalDuration = player.duration;
        console.log('Duration from loadedmetadata:', totalDuration);
        initializeDurationControls();
        status.textContent = `Video loaded: ${formatTime(totalDuration)}`;
        return;
    }
    
    // If duration is problematic, start advanced detection
    console.log('Duration not available in loadedmetadata, starting detection...');
    setTimeout(() => {
        forceDurationDetection();
    }, 500);
});

player.addEventListener('loadeddata', () => {
    console.log('loadeddata event fired');
    
    // Try another detection after loadeddata
    setTimeout(() => {
        if (!totalDuration || totalDuration <= 0) {
            forceDurationDetection();
        }
    }, 1000);
});

// Add progress event for better duration detection
player.addEventListener('progress', () => {
    // Check if we can get duration from buffered ranges
    if ((!totalDuration || totalDuration <= 0) && player.buffered && player.buffered.length > 0) {
        const bufferedEnd = player.buffered.end(player.buffered.length - 1);
        if (bufferedEnd && bufferedEnd > 0) {
            totalDuration = bufferedEnd;
            console.log('Duration detected from progress event:', totalDuration);
            initializeDurationControls();
        }
    }
});

// Add canplay event as another fallback
player.addEventListener('canplay', () => {
    if ((!totalDuration || totalDuration <= 0) && player.duration && player.duration > 0) {
        totalDuration = player.duration;
        console.log('Duration detected from canplay event:', totalDuration);
        initializeDurationControls();
    }
});

// Add timeupdate event for final fallback
let lastDurationCheck = 0;
player.addEventListener('timeupdate', () => {
    // Check duration every 5 seconds as a final fallback
    const now = Date.now();
    if (now - lastDurationCheck > 5000 && (!totalDuration || totalDuration <= 0)) {
        lastDurationCheck = now;
        
        // Try all available methods
        if (player.duration && player.duration > 0) {
            totalDuration = player.duration;
        } else if (player.seekable && player.seekable.length > 0) {
            totalDuration = player.seekable.end(player.seekable.length - 1);
        } else if (player.buffered && player.buffered.length > 0) {
            totalDuration = player.buffered.end(player.buffered.length - 1);
        }
        
        if (totalDuration > 0) {
            console.log('Duration detected from timeupdate event:', totalDuration);
            initializeDurationControls();
        }
    }
});

player.addEventListener('play', () => {
isPlaying = true;
playPauseBtn.textContent = '‚è∏';
});

player.addEventListener('pause', () => {
isPlaying = false;
playPauseBtn.textContent = '‚ñ∂';
});

// Captions functions
function clearCaptions() {
captions = [];
updateCaptionsDisplay();
}

function updateCaptionsDisplay() {
if (captions.length === 0) {
captionsPanel.innerHTML = '<div class="no-captions">No captions generated yet. Click "Generate" to create captions from audio.</div>';
return;
}
let html = '';
captions.forEach((caption, index) => {
html += `
<div class="caption-line">
<span class="caption-time">${formatTime(caption.start)} ‚Üí ${formatTime(caption.end)}</span>
<span class="caption-text">${caption.text}</span>
</div>
`;
});
captionsPanel.innerHTML = html;
captionsPanel.scrollTop = captionsPanel.scrollHeight;
}

async function generateCaptions() {
if (!player.src) {
showError('Load a video first.');
return;
}
if (isGeneratingCaptions) {
showError('Caption generation already in progress.');
return;
}
const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SpeechRecognitionAPI) {
showError('Speech recognition not supported in this browser. Try Chrome or Edge.');
return;
}
isGeneratingCaptions = true;
generateCaptionsBtn.textContent = 'Generating...';
generateCaptionsBtn.disabled = true;
clearCaptionsBtn.disabled = true;
status.textContent = 'Starting caption generation...';
captionsPanel.innerHTML = '<div class="no-captions">Starting speech recognition...</div>';
try {
speechRecognition = new SpeechRecognitionAPI();
speechRecognition.continuous = true;
speechRecognition.interimResults = true;
speechRecognition.lang = 'en-US';
speechRecognition.onresult = (event) => {
for (let i = event.resultIndex; i < event.results.length; ++i) {
if (event.results[i].isFinal) {
captions.push({
text: event.results[i][0].transcript,
start: player.currentTime - 2,
end: player.currentTime
});
}
}
updateCaptionsDisplay();
};
speechRecognition.onerror = (event) => {
console.error('Speech recognition error:', event.error);
isGeneratingCaptions = false;
generateCaptionsBtn.textContent = 'Generate';
generateCaptionsBtn.disabled = false;
clearCaptionsBtn.disabled = false;
let errorMessage = 'Speech recognition error';
switch(event.error) {
case 'no-speech':
errorMessage = 'No speech detected. Try a video with clearer audio.';
break;
case 'audio-capture':
errorMessage = 'Audio capture failed. Check microphone permissions.';
break;
case 'not-allowed':
errorMessage = 'Microphone access denied. Please allow microphone access.';
break;
}
showError(errorMessage);
status.textContent = 'Caption generation failed';
};
speechRecognition.onend = () => {
isGeneratingCaptions = false;
generateCaptionsBtn.textContent = 'Generate';
generateCaptionsBtn.disabled = false;
clearCaptionsBtn.disabled = false;
status.textContent = `Generated ${captions.length} caption lines`;
};
speechRecognition.start();
setTimeout(() => {
if (isGeneratingCaptions) {
speechRecognition.stop();
}
}, 30000);
} catch (error) {
console.error('Caption generation error:', error);
isGeneratingCaptions = false;
generateCaptionsBtn.textContent = 'Generate';
generateCaptionsBtn.disabled = false;
clearCaptionsBtn.disabled = false;
showError(`Failed to generate captions: ${error.message}`);
status.textContent = 'Caption generation failed';
}
}

function exportCaptionsAsSRT() {
if (captions.length === 0) {
showError('No captions to export.');
return;
}
let srtContent = '';
captions.forEach((caption, index) => {
const formatSRTTime = (seconds) => {
const hrs = Math.floor(seconds / 3600);
const mins = Math.floor((seconds % 3600) / 60);
const secs = Math.floor(seconds % 60);
const ms = Math.floor((seconds % 1) * 1000);
return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
};
srtContent += `${index + 1}
`;
srtContent += `${formatSRTTime(caption.start)} --> ${formatSRTTime(caption.end)}
`;
srtContent += `${caption.text}
`;
});
const blob = new Blob([srtContent], { type: 'text/plain' });
const url = URL.createObjectURL(blob);
const filename = (currentFile && currentFile.name.replace(/\.[^.]+$/, '')) || 'video';
const tempLink = document.createElement('a');
tempLink.href = url;
tempLink.download = `${filename}_captions.srt`;
tempLink.style.display = 'none';
document.body.appendChild(tempLink);
tempLink.click();
document.body.removeChild(tempLink);
setTimeout(() => {
URL.revokeObjectURL(url);
}, 1000);
status.textContent = `Exported ${captions.length} caption lines as SRT`;
}

// Range sync
function syncFromRanges() {
let s = parseFloat(startRange.value);
let e = parseFloat(endRange.value);
if (e < s) {
e = s + 0.01;
endRange.value = e;
}
startInput.value = formatTime(s);
endInput.value = formatTime(e);
manualStart.value = formatTime(s);
manualEnd.value = formatTime(e);
updateSegmentDuration();
updateTimeline();
}

startRange.addEventListener('input', syncFromRanges);
endRange.addEventListener('input', syncFromRanges);

// Time input sync
startInput.addEventListener('input', () => {
const s = Math.max(0, Math.min(totalDuration || 0, parseTimeInput(startInput.value)));
if (!isNaN(s)) {
startRange.value = s;
updateSegmentDuration();
updateTimeline();
}
});

endInput.addEventListener('input', () => {
const e = Math.max(0, Math.min(totalDuration || 0, parseTimeInput(endInput.value)));
if (!isNaN(e)) {
endRange.value = e;
updateSegmentDuration();
updateTimeline();
}
});

// Percentage input
applyPercentBtn.addEventListener('click', () => {
const startPercent = parseFloat(startPercentInput.value);
const endPercent = parseFloat(endPercentInput.value);
if (isNaN(startPercent) || isNaN(endPercent)) {
showError('Please enter valid percentages (0-100)');
return;
}
if (startPercent < 0 || startPercent > 100 || endPercent < 0 || endPercent > 100) {
showError('Percentages must be between 0 and 100');
return;
}
if (endPercent <= startPercent) {
showError('End percentage must be greater than start percentage');
return;
}
const s = (startPercent / 100) * totalDuration;
const e = (endPercent / 100) * totalDuration;
startRange.value = s;
endRange.value = e;
syncFromRanges();
player.currentTime = s;
status.textContent = `Times set by percentage: ${startPercent.toFixed(1)}% ‚Üí ${endPercent.toFixed(1)}%`;
hideError();
});

// Manual time entry
applyManualTimes.addEventListener('click', () => {
const s = Math.max(0, Math.min(totalDuration || 0, parseTimeInput(manualStart.value)));
const e = Math.max(0, Math.min(totalDuration || 0, parseTimeInput(manualEnd.value)));
if (isNaN(s) || isNaN(e)) {
showError('Please enter valid times (e.g., 1:23.45 or 83.45)');
return;
}
if (e <= s) {
showError('End time must be greater than start time');
return;
}
startRange.value = s;
endRange.value = e;
syncFromRanges();
player.currentTime = s;
status.textContent = `Times set: ${formatTime(s)} ‚Üí ${formatTime(e)}`;
});

// Volume slider
volumeSlider.addEventListener('input', updateVolumeDisplay);

// Volume presets
volumePresets.forEach(preset => {
preset.addEventListener('click', () => {
const volume = parseInt(preset.dataset.volume);
volumeSlider.value = volume;
updateVolumeDisplay();
});
});

// Enhanced controls
playPauseBtn.addEventListener('click', () => {
if (player.paused) {
player.play();
} else {
player.pause();
}
});

frameBackBtn.addEventListener('click', () => {
player.currentTime = Math.max(0, player.currentTime - 0.1);
});

frameForwardBtn.addEventListener('click', () => {
player.currentTime = Math.min(totalDuration, player.currentTime + 0.1);
});

jumpBack5Btn.addEventListener('click', () => {
player.currentTime = Math.max(0, player.currentTime - 5);
});

jumpForward5Btn.addEventListener('click', () => {
player.currentTime = Math.min(totalDuration, player.currentTime + 5);
});

setStartBtn.addEventListener('click', () => {
startRange.value = player.currentTime;
syncFromRanges();
status.textContent = `Start set to ${formatTime(player.currentTime)}`;
hideError();
});

setEndBtn.addEventListener('click', () => {
endRange.value = player.currentTime;
syncFromRanges();
status.textContent = `End set to ${formatTime(player.currentTime)}`;
hideError();
});

// Quick jump buttons
quickJumpButtons.forEach(btn => {
btn.addEventListener('click', () => {
const seconds = parseFloat(btn.dataset.seconds);
player.currentTime = Math.max(0, Math.min(totalDuration, player.currentTime + seconds));
});
});

percentJumpButtons.forEach(btn => {
btn.addEventListener('click', () => {
const percentChange = parseFloat(btn.dataset.percent);
const currentPercent = (player.currentTime / totalDuration) * 100;
const newPercent = Math.max(0, Math.min(100, currentPercent + percentChange));
player.currentTime = (newPercent / 100) * totalDuration;
});
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
switch(e.key) {
case ' ':
case 'Spacebar':
e.preventDefault();
playPauseBtn.click();
break;
case 'ArrowLeft':
e.preventDefault();
frameBackBtn.click();
break;
case 'ArrowRight':
e.preventDefault();
frameForwardBtn.click();
break;
case 's':
case 'S':
e.preventDefault();
setStartBtn.click();
break;
case 'e':
case 'E':
e.preventDefault();
setEndBtn.click();
break;
case 'a':
case 'A':
e.preventDefault();
if (!isExporting) {
extractAudioBtn.click();
}
break;
case 'ArrowUp':
e.preventDefault();
const currentVol = parseInt(volumeSlider.value);
const newVol = Math.min(300, currentVol + 10);
volumeSlider.value = newVol;
updateVolumeDisplay();
break;
case 'ArrowDown':
e.preventDefault();
const currentVol2 = parseInt(volumeSlider.value);
const newVol2 = Math.max(0, currentVol2 - 10);
volumeSlider.value = newVol2;
updateVolumeDisplay();
break;
case 'c':
case 'C':
e.preventDefault();
if (!isGeneratingCaptions) {
generateCaptionsBtn.click();
}
break;
}
});

// Preview
previewBtn.addEventListener('click', async ()=>{
if(!player.src) {
showError('Load a video first.');
return;
}
const s = segmentEnabled && !useFullVideo ? parseFloat(startRange.value) : 0;
const e = segmentEnabled && !useFullVideo ? parseFloat(endRange.value) : totalDuration;
if(e <= s) {
showError('End must be greater than start.');
return;
}
player.currentTime = s;
player.muted = false;
player.play();
status.textContent = `Previewing ${formatTime(s)} ‚Üí ${formatTime(e)}`;
const onTime = ()=>{
if(player.currentTime >= e - 0.05){
player.pause();
player.removeEventListener('timeupdate', onTime);
status.textContent='Preview finished.';
}
};
player.addEventListener('timeupdate', onTime);
hideError();
});

// MODIFIED: Export function to handle full video when no segment selected
trimBtn.addEventListener('click', async () => {
if (isExporting) {
showError('Export already in progress');
return;
}
if(!player.src) {
showError('Load a video first.');
return;
}

// Ensure we have a valid duration
if (!totalDuration || totalDuration <= 0) {
    showError('Cannot detect video duration. Please try loading the video again or use manual time entry.');
    return;
}

// Determine segment times
const s = segmentEnabled && !useFullVideo ? parseFloat(startRange.value) : 0;
const e = segmentEnabled && !useFullVideo ? parseFloat(endRange.value) : totalDuration;
if(e <= s) {
showError('End must be greater than start.');
return;
}

const exportLength = e - s;
// Warning for very long segments but allow them
if (exportLength > 3600) { // 1 hour
const confirmExport = confirm(`This segment is ${formatTime(exportLength)} long. Exporting may take a while and use significant memory. Continue?`);
if (!confirmExport) return;
}

isExporting = true;
// Disable controls
trimBtn.disabled = true;
previewBtn.disabled = true;
extractAudioBtn.disabled = true;
fileInput.disabled = true;
progressEl.style.display='block';
exportProgressInfo.style.display='flex';
progressEl.value = 0;
exportProgressPercent.textContent = '0%';
exportProgressTime.textContent = `${formatTime(0)} / ${formatTime(exportLength)}`;
status.textContent = segmentEnabled && !useFullVideo ? `Starting export of segment...` : `Starting export of full video...`;
hideError();

try {
await optimizedCanvasExport(s, e, exportLength);
} catch(err) {
console.error('Export error:', err);
showError(`Export failed: ${err.message}. Try a shorter segment or lower quality.`);
cleanupExport();
}
});

// MODIFIED: Audio extraction to handle full video when no segment selected
extractAudioBtn.addEventListener('click', async () => {
if (isExporting) {
showError('Export already in progress');
return;
}
if(!player.src) {
showError('Load a video first.');
return;
}

// Ensure we have a valid duration
if (!totalDuration || totalDuration <= 0) {
    showError('Cannot detect video duration. Please try loading the video again or use manual time entry.');
    return;
}

// Determine segment times
const s = segmentEnabled && !useFullVideo ? parseFloat(startRange.value) : 0;
const e = segmentEnabled && !useFullVideo ? parseFloat(endRange.value) : totalDuration;
if(e <= s) {
showError('End must be greater than start.');
return;
}

const exportLength = e - s;
// Warning for very long segments but allow them
if (exportLength > 3600) { // 1 hour
const confirmExport = confirm(`This audio segment is ${formatTime(exportLength)} long. Extraction may take a while. Continue?`);
if (!confirmExport) return;
}

isExporting = true;
// Disable controls
extractAudioBtn.disabled = true;
trimBtn.disabled = true;
previewBtn.disabled = true;
fileInput.disabled = true;
progressEl.style.display='block';
exportProgressInfo.style.display='flex';
progressEl.value = 0;
exportProgressPercent.textContent = '0%';
exportProgressTime.textContent = `${formatTime(0)} / ${formatTime(exportLength)}`;
status.textContent = segmentEnabled && !useFullVideo ? `Starting audio extraction...` : `Starting full audio extraction...`;
hideError();

try {
await extractAudioOnly(s, e, exportLength);
} catch(err) {
console.error('Audio extraction error:', err);
showError(`Audio extraction failed: ${err.message}. Try a shorter segment or different format.`);
cleanupExport();
}
});

// Audio extraction function - FIXED VERSION with MP3 and WAV support and unlimited downloads
async function extractAudioOnly(s, e, exportLength) {
return new Promise(async (resolve, reject) => {
try {
// Hide warnings at start
audioFormatWarning.style.display = 'none';
convertingProgress.style.display = 'none';

// Get audio settings
const audioFormat = audioFormatSelect.value;
const audioQuality = audioQualitySelect.value;

// For WAV format, use Web Audio API for better quality
if (audioFormat === 'wav') {
    // Show status
    status.textContent = 'Preparing WAV audio extraction...';
    
    try {
        // Create audio context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Fetch the video as array buffer
        const response = await fetch(player.src);
        const arrayBuffer = await response.arrayBuffer();
        
        // Decode audio data
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // Extract the segment
        const sampleRate = audioBuffer.sampleRate;
        const startSample = Math.floor(s * sampleRate);
        const endSample = Math.floor(e * sampleRate);
        const segmentLength = endSample - startSample;
        
        // Create a new AudioBuffer for the segment
        const segmentBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            segmentLength,
            sampleRate
        );
        
        // Copy audio data with volume adjustment
        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const channelData = audioBuffer.getChannelData(channel);
            const segmentData = segmentBuffer.getChannelData(channel);
            for (let i = 0; i < segmentLength; i++) {
                segmentData[i] = channelData[startSample + i] * currentVolume;
            }
        }
        
        // Convert to WAV
        const wavBlob = audioBufferToWav(segmentBuffer, 1.0); // Volume already applied
        
        // Close audio context
        await audioContext.close();
        
        // Store export - THE KEY FIX: Keep blob in memory for unlimited downloads
        const exportId = nextExportId++;
        const filenameBase = (currentFile && currentFile.name.replace(/\.[^.]+$/, '')) || 'audio';
        const segmentText = segmentEnabled && !useFullVideo ? `_${formatTime(s).replace(/:/g, '-')}_to_${formatTime(e)}` : '_full';
        const filename = `${filenameBase}${segmentText}.wav`;
        
        exports.push({
            id: exportId,
            blob: wavBlob, // Keep blob reference for unlimited downloads
            filename: filename,
            format: 'WAV',
            duration: exportLength,
            size: wavBlob.size,
            volume: currentVolume,
            timestamp: Date.now(),
            type: 'audio',
            audioQuality: 'Lossless'
        });
        
        // Create download container
        addDownloadContainer(exportId);
        
        // Auto-download first time
        setTimeout(() => { downloadExport(exportId); }, 500);
        
        status.textContent = `WAV audio ready ‚Äî ${(wavBlob.size/1024/1024).toFixed(2)} MB (Lossless)`;
        showExportCompleteMessage();
        cleanupOldExports(exportId);
        cleanupExport();
        resolve();
        return;
        
    } catch (wavError) {
        console.error('WAV extraction failed, falling back to MediaRecorder:', wavError);
        // Fall through to MediaRecorder method
    }
}

// For other formats, use MediaRecorder method
const mimeType = getAudioMimeType(audioFormat);
const audioBitrate = getAudioBitrate(audioQuality, audioFormat);

// Create processing video element
const processingVideo = document.createElement('video');
processingVideo.src = player.src;
processingVideo.muted = false;
processingVideo.crossOrigin = 'anonymous';
processingVideo.style.display = 'none';
document.body.appendChild(processingVideo);

// Wait for video to load
await new Promise((resolveLoad, rejectLoad) => {
processingVideo.onloadedmetadata = resolveLoad;
processingVideo.onerror = rejectLoad;
setTimeout(() => rejectLoad(new Error('Video loading timeout')), 15000);
});

// Audio setup
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const source = audioContext.createMediaElementSource(processingVideo);
const gainNode = audioContext.createGain();
const volume = currentVolume; // Use current volume setting
gainNode.gain.value = volume;
const destination = audioContext.createMediaStreamDestination();
source.connect(gainNode);
gainNode.connect(destination);
gainNode.connect(audioContext.destination);

// Try to create recorder with error handling
let recorder;
try {
recorder = new MediaRecorder(destination.stream, {
mimeType: mimeType,
audioBitsPerSecond: audioFormat === 'mp3' ? 128000 : audioBitrate
});
} catch (recorderError) {
console.error('MediaRecorder creation failed:', recorderError);
// Try fallback without mimeType
try {
recorder = new MediaRecorder(destination.stream, {
audioBitsPerSecond: audioFormat === 'mp3' ? 128000 : audioBitrate
});
audioFormatWarning.style.display = 'block';
audioFormatWarning.textContent = '‚ö†Ô∏è Selected audio format not supported. Using browser default format.';
} catch (fallbackError) {
console.error('Fallback MediaRecorder also failed:', fallbackError);
throw new Error('Audio recording not supported in this browser');
}
}

const chunks = [];
recorder.ondataavailable = (event) => {
if (event.data.size > 0) {
chunks.push(event.data);
}
};

recorder.onstop = async () => {
try {
// Get the original format from MIME type
let originalFormat = 'wav';
if (recorder.mimeType) {
if (recorder.mimeType.includes('ogg')) originalFormat = 'ogg';
else if (recorder.mimeType.includes('webm')) originalFormat = 'webm';
else if (recorder.mimeType.includes('mp4')) originalFormat = 'm4a';
}

// Create initial blob
const initialBlob = new Blob(chunks, { type: recorder.mimeType || 'audio/wav' });

// Á´ãÂç≥Ê∏ÖÁêÜchunksÊï∞ÁªÑÈáäÊîæÂÜÖÂ≠ò
chunks.length = 0;

// Ê∏ÖÁêÜMediaStream
destination.stream.getTracks().forEach(track => track.stop());

// Á°Æ‰øùÈü≥È¢ë‰∏ä‰∏ãÊñáÂÖ≥Èó≠
if (audioContext.state !== 'closed') {
await audioContext.close();
}

// ÁßªÈô§ÂÖÉÁ¥†
if (processingVideo.parentNode) {
document.body.removeChild(processingVideo);
}

let finalBlob = initialBlob;
let finalFormat = audioFormat;

// Convert to MP3 if selected
if (audioFormat === 'mp3') {
try {
// Show conversion progress
status.textContent = 'Converting to MP3 format...';
// Convert the audio to MP3
finalBlob = await convertAudioToMp3(initialBlob, originalFormat, audioBitrate);
finalFormat = 'mp3';
} catch (conversionError) {
console.error('MP3 conversion error:', conversionError);
audioFormatWarning.style.display = 'block';
audioFormatWarning.textContent = '‚ö†Ô∏è MP3 conversion failed. Using WAV format instead.';
finalFormat = 'wav';
}
}

// Store audio export - THE KEY FIX: Keep blob in memory for unlimited downloads
const exportId = nextExportId++;
const filenameBase = (currentFile && currentFile.name.replace(/\.[^.]+$/, '')) || 'audio';
const segmentText = segmentEnabled && !useFullVideo ? `_${formatTime(s).replace(/:/g, '-')}_to_${formatTime(e)}` : '_full';
const filename = `${filenameBase}${segmentText}.${finalFormat}`;
exports.push({
id: exportId,
blob: finalBlob, // Keep blob reference for unlimited downloads
filename: filename,
format: finalFormat.toUpperCase(),
duration: exportLength,
size: finalBlob.size,
volume: volume,
timestamp: Date.now(),
type: 'audio',
audioQuality: audioQuality
});

// Create download container
addDownloadContainer(exportId);

// Auto-download first time
setTimeout(() => {
downloadExport(exportId);
}, 500);

const qualityText = audioFormat === 'mp3' ? `${audioBitrate}kbps` : audioQuality;
status.textContent = `Audio ready ‚Äî ${(finalBlob.size/1024/1024).toFixed(2)} MB ${finalFormat.toUpperCase()} (${qualityText})`;

// ÊòæÁ§∫ÂØºÂá∫ÂÆåÊàêÊèêÁ§∫
showExportCompleteMessage();

// Ê∏ÖÁêÜÊóßÁöÑÂØºÂá∫Êï∞ÊçÆ
cleanupOldExports(exportId);
cleanupExport();
resolve();
} catch (error) {
reject(error);
}
};

recorder.onerror = (event) => {
console.error('Audio recorder error:', event);
reject(new Error('Audio recording failed'));
};

// Start recording
const chunkSize = Math.min(1000, exportLength * 1000 / 10); // Adaptive chunk size
recorder.start(chunkSize);

// Seek and prepare
processingVideo.currentTime = s;
await new Promise(resolveSeek => {
processingVideo.onseeked = resolveSeek;
setTimeout(resolveSeek, 200);
});

// Start playback
await processingVideo.play();
// ADDED: Sync delay to ensure smooth audio-video sync
await new Promise(resolve => setTimeout(resolve, 100));

let isExportingActive = true;
let startTime = Date.now();

// Monitor progress
function updateAudioProgress() {
if (!isExportingActive) return;
const videoTime = processingVideo.currentTime;
const progress = (videoTime - s) / exportLength;
progressEl.value = progress;
exportProgressPercent.textContent = `${(progress * 100).toFixed(1)}%`;
exportProgressTime.textContent = `${formatTime(videoTime - s)} / ${formatTime(exportLength)}`;

// Check if finished
if (videoTime >= e || processingVideo.ended) {
isExportingActive = false;
processingVideo.pause();
recorder.stop();
return;
}
requestAnimationFrame(updateAudioProgress);
}

// Start progress monitoring
requestAnimationFrame(updateAudioProgress);

// Safety timeout
const safetyTimeout = (exportLength * 1000) + 30000;
exportTimeout = setTimeout(() => {
if (isExportingActive) {
isExportingActive = false;
processingVideo.pause();
if (recorder.state !== 'inactive') {
recorder.stop();
}
}
}, safetyTimeout);
} catch (error) {
reject(error);
}
});
}

// Ê∏ÖÁêÜÂØºÂá∫ÂáΩÊï∞
function cleanupExport() {
progressEl.style.display = 'none';
exportProgressInfo.style.display = 'none';
trimBtn.disabled = false;
previewBtn.disabled = false;
extractAudioBtn.disabled = false;
fileInput.disabled = false;
isExporting = false;
if (exportTimeout) {
clearTimeout(exportTimeout);
exportTimeout = null;
}
// Ê∏ÖÁêÜÊâÄÊúâ‰∏¥Êó∂ÂÖÉÁ¥†
cleanupTemporaryElements();
}

// FIXED: Optimized canvas export with fixed frame rate to prevent freezing
async function optimizedCanvasExport(s, e, exportLength) {
return new Promise(async (resolve, reject) => {
try {
// Create processing elements
const processingVideo = document.createElement('video');
processingVideo.src = player.src;
processingVideo.muted = false;
processingVideo.crossOrigin = 'anonymous';
processingVideo.style.display = 'none';
processingVideo.preload = 'auto';
processingVideo.playsInline = true;
document.body.appendChild(processingVideo);

// Wait for video to load
await new Promise((resolveLoad, rejectLoad) => {
processingVideo.onloadedmetadata = resolveLoad;
processingVideo.onerror = rejectLoad;
setTimeout(() => rejectLoad(new Error('Video loading timeout')), 15000);
});

// Set up canvas with optimized settings
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d', {
alpha: false,
desynchronized: enableHardwareAccel.checked // Hardware acceleration
});

// Use optimal dimensions
let targetWidth, targetHeight;
if (resizeCheckbox.checked) {
targetWidth = 1280;
targetHeight = 720;
} else {
targetWidth = processingVideo.videoWidth;
targetHeight = processingVideo.videoHeight;
// Cap dimensions for performance with long videos
if (exportLength > 600 && targetWidth > 1280) { // If longer than 10 minutes
targetHeight = Math.round(targetHeight * (1280 / targetWidth));
targetWidth = 1280;
}
}
canvas.width = targetWidth;
canvas.height = targetHeight;

// Audio setup
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const source = audioContext.createMediaElementSource(processingVideo);
const gainNode = audioContext.createGain();
const volume = muteCheckbox.checked ? 0 : currentVolume;
gainNode.gain.value = volume;
const destination = audioContext.createMediaStreamDestination();
source.connect(gainNode);
gainNode.connect(destination);
gainNode.connect(audioContext.destination);

// Get user's selected format and quality
const userFormat = selectedFormat;
const quality = qualitySelect.value;

// Get supported mime type that respects user selection
const formatInfo = getSupportedMimeType(userFormat, quality);
const actualFormat = formatInfo.format; // This will be the actual format used
const mimeType = formatInfo.mimeType;

// Show format info in status
if (actualFormat !== userFormat) {
status.textContent = `Exporting as ${actualFormat.toUpperCase()} (${userFormat.toUpperCase()} not supported)`;
formatWarning.style.display = 'block';
formatWarning.textContent = `‚ö†Ô∏è ${userFormat.toUpperCase()} not supported. Using ${actualFormat.toUpperCase()} instead.`;
} else {
status.textContent = `Exporting as ${actualFormat.toUpperCase()}...`;
formatWarning.style.display = 'none';
}

// Configure bitrate based on quality and length
const bitrates = {
'high': { video: exportLength > 600 ? 2000000 : 2500000, audio: 192000 },
'medium': { video: exportLength > 600 ? 1000000 : 1500000, audio: 128000 },
'low': { video: exportLength > 600 ? 500000 : 750000, audio: 64000 }
};
const bitrate = bitrates[quality] || bitrates.medium;

// FIXED: Use fixed frame rate for consistent playback
const fps = 25; // Always use 25 FPS for consistent results

// Capture streams
const canvasStream = canvas.captureStream(fps);
const combinedStream = new MediaStream([
...canvasStream.getVideoTracks(),
...destination.stream.getAudioTracks()
]);

// Create recorder with optimized settings
const recorder = new MediaRecorder(combinedStream, {
mimeType: mimeType,
videoBitsPerSecond: bitrate.video,
audioBitsPerSecond: bitrate.audio
});

const chunks = [];
recorder.ondataavailable = (event) => {
if (event.data.size > 0) {
chunks.push(event.data);
}
};

recorder.onstop = async () => {
try {
const blob = new Blob(chunks, { type: mimeType });

// Á´ãÂç≥Ê∏ÖÁêÜchunksÊï∞ÁªÑÈáäÊîæÂÜÖÂ≠ò
chunks.length = 0;

// Ê∏ÖÁêÜMediaStream
canvasStream.getTracks().forEach(track => track.stop());
destination.stream.getTracks().forEach(track => track.stop());
combinedStream.getTracks().forEach(track => track.stop());

// ÂÅúÊ≠¢Âπ∂Ê∏ÖÁêÜprocessingVideo
processingVideo.pause();
processingVideo.src = '';
processingVideo.load();

// Á°Æ‰øùÈü≥È¢ë‰∏ä‰∏ãÊñáÂÖ≥Èó≠
if (audioContext.state !== 'closed') {
await audioContext.close();
}

// ÁßªÈô§ÂÖÉÁ¥†
if (processingVideo.parentNode) {
document.body.removeChild(processingVideo);
}
if (canvas.parentNode) {
document.body.removeChild(canvas);
}

// Store export - Keep blob in memory for unlimited downloads
const exportId = nextExportId++;
const filenameBase = (currentFile && currentFile.name.replace(/\.[^.]+$/, '')) || 'video';
const extension = actualFormat; // Use actual format for filename
const segmentText = segmentEnabled && !useFullVideo ? `_${formatTime(s).replace(/:/g, '-')}_to_${formatTime(e).replace(/:/g, '-')}` : '_full';
const filename = `${filenameBase}${segmentText}.${extension}`;
exports.push({
id: exportId,
blob: blob, // Keep blob reference for unlimited downloads
filename: filename,
format: extension.toUpperCase(),
duration: exportLength,
size: blob.size,
volume: muteCheckbox.checked ? 0 : currentVolume,
timestamp: Date.now(),
requestedFormat: userFormat.toUpperCase(),
actualFormat: actualFormat.toUpperCase(),
type: 'video'
});

// Create download container
addDownloadContainer(exportId);

// Auto-download first time
setTimeout(() => {
downloadExport(exportId);
}, 500);

const audioStatusText = muteCheckbox.checked ? 'muted' : (currentVolume !== 1.0 ? `${currentVolume.toFixed(1)}x volume` : 'with audio');
let formatStatus = '';
if (userFormat !== actualFormat) {
formatStatus = ` (${userFormat.toUpperCase()} ‚Üí ${actualFormat.toUpperCase()})`;
}
status.textContent = `Export ready ‚Äî ${(blob.size/1024/1024).toFixed(2)} MB ${actualFormat.toUpperCase()}${formatStatus} (${audioStatusText})`;

// ÊòæÁ§∫ÂØºÂá∫ÂÆåÊàêÊèêÁ§∫
showExportCompleteMessage();

// Ê∏ÖÁêÜÊóßÁöÑÂØºÂá∫Êï∞ÊçÆ
cleanupOldExports(exportId);
cleanupExport();
resolve();
} catch (error) {
reject(error);
}
};

recorder.onerror = (event) => {
console.error('Recorder error:', event);
reject(new Error('Recording failed'));
};

// Start recording with larger chunks for long videos
const chunkSize = exportLength > 300 ? 5000 : 1000; // 5 second chunks for long videos
recorder.start(chunkSize);

// Seek and prepare
processingVideo.currentTime = s;
await new Promise(resolveSeek => {
processingVideo.onseeked = resolveSeek;
setTimeout(resolveSeek, 200);
});

// Wait for video to be ready
await new Promise(resolve => {
const checkReady = () => {
if (processingVideo.readyState >= 2) { // HAVE_CURRENT_DATA
resolve();
} else {
setTimeout(checkReady, 50);
}
};
checkReady();
});

// Start playback
await processingVideo.play();
// ADDED: Sync delay to ensure smooth audio-video sync
await new Promise(resolve => setTimeout(resolve, 100));

// FIXED: Fixed frame rate rendering to prevent freezing
let frameCount = 0;
let startTime = Date.now();
let isExportingActive = true;
const frameInterval = 1000 / fps; // Fixed interval based on FPS
let lastFrameTime = startTime;

function renderFrame() {
if (!isExportingActive) return;

const now = Date.now();
const elapsed = now - lastFrameTime;
const expectedFrames = Math.floor(elapsed / frameInterval);

if (expectedFrames > 0) {
// Draw frame
ctx.drawImage(processingVideo, 0, 0, canvas.width, canvas.height);
frameCount += expectedFrames;
lastFrameTime = now - (elapsed % frameInterval);

// Update progress every 0.5 seconds
if (frameCount % Math.floor(fps / 2) === 0) {
const videoTime = processingVideo.currentTime;
const progress = (videoTime - s) / exportLength;
progressEl.value = progress;
exportProgressPercent.textContent = `${(progress * 100).toFixed(1)}%`;
exportProgressTime.textContent = `${formatTime(videoTime - s)} / ${formatTime(exportLength)}`;
}
}

// Check if finished
const videoTime = processingVideo.currentTime;
if (videoTime >= e - 0.05 || processingVideo.ended) {
isExportingActive = false;
processingVideo.pause();
recorder.stop();
return;
}

requestAnimationFrame(renderFrame);
}

// Start rendering
requestAnimationFrame(renderFrame);

// Safety timeout based on video length
const safetyTimeout = (exportLength * 1000) + 30000; // 30 seconds extra
exportTimeout = setTimeout(() => {
if (isExportingActive) {
isExportingActive = false;
processingVideo.pause();
if (recorder.state !== 'inactive') {
recorder.stop();
}
}
}, safetyTimeout);
} catch (error) {
reject(error);
}
});
}

// Add download container to sidebar with format info
function addDownloadContainer(exportId) {
const exportData = exports.find(e => e.id === exportId);
if (!exportData) return;

const downloadContainer = document.createElement('div');
downloadContainer.className = 'download-container';
downloadContainer.dataset.exportId = exportId;

let audioInfo = '';
if (exportData.volume === 0) {
audioInfo = '<span style="font-size:11px; margin-left:4px; color:var(--muted);">üîá Muted</span>';
} else if (exportData.volume !== 1.0) {
audioInfo = `<span style="font-size:11px; margin-left:4px; color:#10b981;">üîä ${exportData.volume.toFixed(1)}x</span>`;
}

// Show format info based on type
let formatInfo = '';
if (exportData.type === 'audio') {
formatInfo = `<span class="audio-format-badge">${exportData.format}</span>`;
if (exportData.audioQuality) {
const qualityText = exportData.format === 'MP3' ? `${exportData.audioQuality}kbps` : exportData.audioQuality;
formatInfo += ` <span class="audio-quality-badge">${qualityText}</span>`;
}
} else {
formatInfo = `<span style="font-size:11px; padding:2px 6px; border-radius:4px; background:var(--accent); color:white;">${exportData.format}</span>`;
if (exportData.requestedFormat && exportData.actualFormat && exportData.requestedFormat !== exportData.actualFormat) {
formatInfo = `<span style="font-size:11px; padding:2px 6px; border-radius:4px; background:var(--accent); color:white;" title="Requested: ${exportData.requestedFormat}, Actual: ${exportData.actualFormat}">${exportData.actualFormat} (from ${exportData.requestedFormat})</span>`;
}
}

downloadContainer.innerHTML = `
<div style="flex: 1;">
<div style="color: #cfe9ff; font-size: 13px; margin-bottom: 2px; display: flex; align-items: center; gap: 6px;">
${exportData.type === 'audio' ? 'üéµ' : 'üé¨'} ${exportData.filename}
</div>
<div style="color: var(--muted); font-size: 11px;">
${(exportData.size/1024/1024).toFixed(2)} MB ‚Ä¢
${formatTime(exportData.duration)} ‚Ä¢
${new Date(exportData.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
</div>
</div>
<div style="display: flex; align-items: center; gap: 8px;">
<div style="display: flex; align-items: center; gap: 2px">
${formatInfo}
${audioInfo}
</div>
<button class="download-btn" data-export-id="${exportId}">Download</button>
</div>
`;

// Add download button handler - FIXED: Unlimited downloads for songs too
const downloadBtn = downloadContainer.querySelector('.download-btn');
downloadBtn.addEventListener('click', (e) => {
e.preventDefault();
e.stopPropagation();
downloadExport(exportId);
// Show feedback
const originalText = downloadBtn.textContent;
downloadBtn.textContent = 'Downloading...';
downloadBtn.disabled = true;
setTimeout(() => {
downloadBtn.textContent = 'Download Again';
downloadBtn.disabled = false;
}, 1000);
});

// Container click
downloadContainer.addEventListener('click', (e) => {
if (!e.target.closest('.download-btn')) {
downloadBtn.click();
}
});

// Add to downloads list
const noExportsMsg = downloads.querySelector('.smallmuted');
if (noExportsMsg && noExportsMsg.textContent.includes('No exports yet')) {
downloads.removeChild(noExportsMsg);
}
downloads.prepend(downloadContainer);
}

// Download export - FIXED: Works for both videos and songs
function downloadExport(exportId) {
const exportData = exports.find(e => e.id === exportId);
if (!exportData || !exportData.blob) {
showError('Export not found or expired. Please export again.');
return;
}
const url = URL.createObjectURL(exportData.blob);
forceDownload(url, exportData.filename);
// Cleanup URL after download
setTimeout(() => {
URL.revokeObjectURL(url);
}, 60000); // Keep URL for 1 minute

// Ê∏ÖÁêÜÊóßÁöÑÂØºÂá∫Êï∞ÊçÆ
cleanupOldExports(exportId);
status.textContent = `Downloading ${exportData.filename}...`;
}

// NEW: Manual duration override button
function addDurationOverrideButton() {
    const durationOverrideBtn = document.createElement('button');
    durationOverrideBtn.className = 'jump-btn';
    durationOverrideBtn.style.marginTop = '8px';
    durationOverrideBtn.style.width = '100%';
    durationOverrideBtn.textContent = '‚ö†Ô∏è Set Manual Duration';
    
    durationOverrideBtn.addEventListener('click', () => {
        const currentDuration = totalDuration || 0;
        const userInput = prompt(`Current detected duration: ${formatTime(currentDuration)}\n\nEnter manual duration (e.g., 1:30, 90, or 1:30:00):`, formatTime(currentDuration));
        
        if (userInput !== null) {
            const parsedDuration = parseTimeInput(userInput);
            if (parsedDuration > 0) {
                totalDuration = parsedDuration;
                initializeDurationControls();
                status.textContent = `Manual duration set: ${formatTime(totalDuration)}`;
                console.log('Manual duration override:', totalDuration);
            } else {
                showError('Invalid duration format. Use seconds (90) or time (1:30)');
            }
        }
    });
    
    // Add to controls container
    const controlsContainer = document.querySelector('.controls-container');
    if (controlsContainer) {
        controlsContainer.appendChild(durationOverrideBtn);
    }
}

// Initialize the app
initializeApp();
addDurationOverrideButton();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
// Clean up animation frame
if (animationFrameId) {
cancelAnimationFrame(animationFrameId);
}
// Clean up timeouts
if (exportTimeout) {
clearTimeout(exportTimeout);
}
// Clean up file URLs
if (fileURL) {
URL.revokeObjectURL(fileURL);
}
// Stop speech recognition if active
if (speechRecognition) {
speechRecognition.stop();
}
// Clean up all exported Blobs
exports.forEach(exp => {
exp.blob = null;
});
exports = [];
// Clean up all temporary elements
cleanupTemporaryElements();
});
})();
</script>
</body>
</html>